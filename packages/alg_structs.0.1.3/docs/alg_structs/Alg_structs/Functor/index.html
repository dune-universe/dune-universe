<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Functor (alg_structs.Alg_structs.Functor)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 0.1.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">alg_structs</a> &#x00BB; <a href="../index.html">Alg_structs</a> &#x00BB; Functor</nav><h1>Module <code>Alg_structs.Functor</code></h1><p>An interface for types that can be mapped over.</p><p>All you need to know to use this module effectively:</p><p>given <code>type 'a t</code>, function <code>map : f:('a -&gt; 'b) -&gt; 'a t -&gt; 'b t</code> will <i>map</i> <code>f</code> &quot;over&quot; <code>t</code> by taking a value of type <code>'a t</code> to a value of type <code>'b
    t</code>.</p><p>E.g., if</p><pre><code class="ml">type 'a t = int list</code></pre><p>then</p><pre><code class="ml">map ~f:Int.to_string : int t -&gt; string t</code></pre><p>is a function which maps <code>int list</code>s to <code>string list</code>s, so</p><pre><code class="ml">map ~f:Int.to_string [1;2;3] = [&quot;1&quot;;&quot;2&quot;;&quot;3&quot;]</code></pre><h2 id="a-rough-sketch-of-the-category-theoretic-basis"><a href="#a-rough-sketch-of-the-category-theoretic-basis" class="anchor"></a>A Rough Sketch of the Category Theoretic Basis</h2><p><i>To repeat, you don't need to read any of the following in order to make use of this module.</i></p><p>The use of the word <i>functor</i> in this context refers to the category theoretic concept of <a href="https://en.wikipedia.org/wiki/Functor">Functor</a>, which is a map between categories. A functor <code>F: C -&gt; D</code> that maps category <code>C</code> to category <code>D</code> consists of two mappings:</p><ol><li>a mapping of each object in <code>C</code> to some object in <code>D</code></li><li>a mapping of each arrow in <code>C</code> to some arrow in <code>D</code></li></ol><p>These mappings must respect the <a href="Law/index.html"><code>Law</code></a>s.</p><p>An &quot;endofunctor&quot; is a functor that is a map of one category within itself (or back onto itself).</p><p>We imagine a category <code>CAML</code> (analogous to <a href="https://wiki.haskell.org/Hask">Hask</a>), where the objects are OCaml types and the arrows are functions between those types. <a href="module-type-S/index.html"><code>S</code></a> then specifies an interface for modules that implement an &quot;endofunctor&quot; on <code>CAML</code>, mapping types to types and functions to functions.</p><nav class="toc"><ul><li><a href="#seed">Seed</a></li><li><a href="#interface">Interface</a></li><li><a href="#laws">Laws</a></li><li><a href="#constructors">Constructors</a></li><li><a href="#implementations">Implementations</a></li></ul></nav></header><section><header><h2 id="seed"><a href="#seed" class="anchor"></a>Seed</h2></header><dl><dt class="spec module-type" id="module-type-Seed"><a href="#module-type-Seed" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Seed/index.html">Seed</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The <code>Seed</code> needed to generate an implementation of <a href="module-type-S/index.html"><span>Functor</span></a>.</p></dd></dl><dl><dt class="spec module-type" id="module-type-UnlabeledSeed"><a href="#module-type-UnlabeledSeed" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-UnlabeledSeed/index.html">UnlabeledSeed</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Interface for a mappable type with an unlabeled <code>map</code> function.</p></dd></dl></section><section><header><h2 id="interface"><a href="#interface" class="anchor"></a>Interface</h2></header><dl><dt class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A module satisfying <a href="module-type-S/index.html"><code>S</code></a> is an implementation of a functor.</p></dd></dl></section><section><header><h2 id="laws"><a href="#laws" class="anchor"></a>Laws</h2></header><dl><dt class="spec module" id="module-Law"><a href="#module-Law" class="anchor"></a><code><span class="keyword">module</span> <a href="Law/index.html">Law</a> : <span class="keyword">functor</span> (<a href="Law/argument-1-F/index.html">F</a> : <a href="index.html#module-type-S">S</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Law</code> notes the laws that should be obeyed by any instantiation of <a href="module-type-S/index.html"><span>Functor</span></a> in the form of predicates that should be true for any arguments of the appropriate type.</p></dd></dl></section><section><header><h2 id="constructors"><a href="#constructors" class="anchor"></a>Constructors</h2><p>Module functors and signatures for expediting instantiation of <a href="module-type-S/index.html"><span>Functors</span></a>.</p></header><div class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-Seed/index.html">Seed</a> : <a href="index.html#module-type-Seed">Seed</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="Make/index.html#type-t">t</a></span> = <span><span class="type-var">'a</span> <a href="Make/argument-1-Seed/index.html#type-t">Seed.t</a></span></code></div><dl><dt class="spec module" id="module-MakeUnlabeled"><a href="#module-MakeUnlabeled" class="anchor"></a><code><span class="keyword">module</span> <a href="MakeUnlabeled/index.html">MakeUnlabeled</a> : <span class="keyword">functor</span> (<a href="MakeUnlabeled/argument-1-Seed/index.html">Seed</a> : <a href="index.html#module-type-UnlabeledSeed">UnlabeledSeed</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="MakeUnlabeled/index.html#type-t">t</a></span> = <span><span class="type-var">'a</span> <a href="MakeUnlabeled/argument-1-Seed/index.html#type-t">Seed.t</a></span></code></dt><dd><p><code>MakeUnlabeled</code> makes an module instantiating <a href="module-type-S/index.html"><code>S</code></a>, with a labeled <a href="module-type-S/index.html#val-map"><code>S.map</code></a>, out of a module instantiating <a href="module-type-UnlabeledSeed/index.html"><code>UnlabeledSeed</code></a> with an unlabeled <code>map</code> function.</p></dd></dl></section><section><header><h2 id="implementations"><a href="#implementations" class="anchor"></a>Implementations</h2></header><div class="spec module" id="module-Option"><a href="#module-Option" class="anchor"></a><code><span class="keyword">module</span> <a href="Option/index.html">Option</a> : <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="module-type-S/index.html#type-t">t</a></span> = <span><span class="type-var">'a</span> Stdlib.Option.t</span></code></div><div class="spec module" id="module-List"><a href="#module-List" class="anchor"></a><code><span class="keyword">module</span> <a href="List/index.html">List</a> : <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="module-type-S/index.html#type-t">t</a></span> = <span><span class="type-var">'a</span> Stdlib.List.t</span></code></div><div class="spec module" id="module-Array"><a href="#module-Array" class="anchor"></a><code><span class="keyword">module</span> <a href="Array/index.html">Array</a> : <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="module-type-S/index.html#type-t">t</a></span> = <span><span class="type-var">'a</span> Stdlib.Array.t</span></code></div></section></div></body></html>