<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Range (range.Range)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">range</a> &#x00BB; Range</nav><h1>Module <code>Range</code></h1><p>Range module provide a type for handling the description of an integer sequence described by a start value and a stop value. This module provide functions to fold this range, and some basic set operation likes cross and join.</p><p>The main goal is to provide a split capacity in order to make life easy for distributed processing.</p><dl><dt>author</dt><dd>Aldrik KLEBER</dd></dl></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code></dt><dd><p>t type correspond to a integer range value</p></dd></dl><dl><dt class="spec value" id="val-from"><a href="#val-from" class="anchor"></a><code><span class="keyword">val </span>from : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>from int_value -&gt; int_value will create a t value representing the range described by the two values given in parameter.</p><dl><dt>parameter start</dt><dd><p>Integer representating the starting value of the range</p></dd></dl><dl><dt>parameter stop</dt><dd><p>Integer representing the last value of the range</p></dd></dl><dl><dt>returns</dt><dd><p>Range.t type which value defined by start and stop parameters</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val </span>filter : (int <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>filter on predicate function attach a predicate that will modify the behaviour of iter or fold funtions in order to apply only to values that satisfies the predicate.</p><dl><dt>parameter predicate</dt><dd><p>the predicate is attached to the range value, the predicate must respect the signature int -&gt; bool</p></dd></dl><dl><dt>parameter Range.t</dt><dd><p>value if the range provided has already a filter, the new range value will merge the two filters.</p></dd></dl><dl><dt>returns</dt><dd><p>new Range.t value with a new filter added. *</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-filtered_from"><a href="#val-filtered_from" class="anchor"></a><code><span class="keyword">val </span>filtered_from : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (int <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>create a new range of integer with a filter</p><p>Application of f is delayed. Filters and map functions can be stacked.</p><dl><dt>parameter start</dt><dd><p>Integer representating the starting value of the range</p></dd></dl><dl><dt>parameter stop</dt><dd><p>Integer representing the last value of the range</p></dd></dl><dl><dt>parameter predicate</dt><dd><p>the predicate is attached to the range value, the predicate must respect the signature int -&gt; bool</p></dd></dl><dl><dt>returns</dt><dd><p>new Range.t type which value defined by start and stop parameters *</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-reset"><a href="#val-reset" class="anchor"></a><code><span class="keyword">val </span>reset : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>remove all map and filter effects from a range.</p><dl><dt>parameter old</dt><dd><p>Range.t value</p></dd></dl><dl><dt>returns</dt><dd><p>new Range.t value from parameter without modifiers. *</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-is_natural"><a href="#val-is_natural" class="anchor"></a><code><span class="keyword">val </span>is_natural : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>is filtered predicate</p><p>test if a Range.t value contain a filter or map function transforming data.</p><dl><dt>parameter Range.t</dt><dd><p>value to test</p></dd></dl><dl><dt>returns</dt><dd><p>test true if there is a filter false otherwise *</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val </span>fold : (<span class="type-var">'a</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>fold the equivalent of List.fold_left applied to integer range_record explore all the values contained in the rang value applying f to the accumulator and the current element read by fold. If a filter was associated to the range value, only element validated by the predicate f will be passed to the function.</p><dl><dt>parameter f</dt><dd><p>function aggregating the accumulator to the current value.</p></dd></dl><dl><dt>parameter acc</dt><dd><p>initial value of the accumulator</p></dd></dl><dl><dt>parameter range</dt><dd><p>explored range value</p></dd></dl><dl><dt>returns</dt><dd><p>value of the accumulator after reading all elements *</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val </span>iter : (int <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>iter apply a function with side effect on all values of the range. This function support filtering.</p><dl><dt>parameter f</dt><dd><p>function receiving an integer and returning unit</p></dd></dl><dl><dt>parameter range</dt><dd><p>value</p></dd></dl><dl><dt>returns</dt><dd><p>unit *</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val </span>split : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list</code></dt><dd><p>split a range value into a list of smaller range, useful for batching in parallel processing.</p><dl><dt>parameter minimal</dt><dd><p>size of a range</p></dd></dl><dl><dt>parameter count</dt><dd><p>number of subranges contained in the list.</p></dd></dl><dl><dt>parameter range</dt><dd><p>value to split</p></dd></dl><dl><dt>returns</dt><dd><p>list of ranges with a size of minimal or greater, the list having count elements max. *</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-contain"><a href="#val-contain" class="anchor"></a><code><span class="keyword">val </span>contain : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>contain function to test if an integer value is contained in a Range.t values</p><dl><dt>parameter element</dt><dd><p>to be tested</p></dd></dl><dl><dt>parameter reference</dt><dd><p>range value</p></dd></dl><dl><dt>returns</dt><dd><p>true if element is contained in reference *</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cross"><a href="#val-cross" class="anchor"></a><code><span class="keyword">val </span>cross : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-t">t</a>, string) Stdlib.result</code></dt><dd><p>new Range.t value representing the common value between two Range.t values.</p><dl><dt>parameter a</dt><dd><p>Range.t value</p></dd></dl><dl><dt>parameter b</dt><dd><p>Range.t value</p></dd></dl><dl><dt>returns</dt><dd><p>Result type with a Range.t value defined by the common values, and Error string message if it is impossible to find common values. *</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cross_exn"><a href="#val-cross_exn" class="anchor"></a><code><span class="keyword">val </span>cross_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Same as cross function with exception for error handling. *</p></dd></dl><dl><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val </span>join : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-t">t</a>, string) Stdlib.result</code></dt><dd><p>Join to generate a new Range.t value contained both a and b</p><dl><dt>parameter a</dt><dd><p>Range.t value</p></dd></dl><dl><dt>parameter b</dt><dd><p>Range.t value</p></dd></dl><dl><dt>returns</dt><dd><p>Result type with a Range.t value containing both a and b. If a and b are disjoint, they can't be joinded so an Error string message is returned. *</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-join_exn"><a href="#val-join_exn" class="anchor"></a><code><span class="keyword">val </span>join_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Same as join with exception for error handling *</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val </span>map : (int <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>apply f to elements contained in a Range.t value</p><p>This feature used a delayed application of f. Like for filters, f is stacked on previous filter or map functions.</p><dl><dt>parameter f</dt><dd><p>function to apply to the content of a range value</p></dd></dl><dl><dt>parameter r</dt><dd><p>range to modify</p></dd></dl><dl><dt>returns</dt><dd><p>updated range *</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-aggregate"><a href="#val-aggregate" class="anchor"></a><code><span class="keyword">val </span>aggregate : (int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>agregate the limits of a range through a function.</p><dl><dt>parameter f</dt><dd><p>function to aggregate an integer</p></dd></dl><dl><dt>parameter a</dt><dd><p>range a to be aggregated to b</p></dd></dl><dl><dt>parameter b</dt><dd><p>range b aggregated to a</p></dd></dl><dl><dt>returns</dt><dd><p>a new range *</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val </span>to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>export limits of a range to a string.</p><p>The presence of functions that can modifiy the content is signaled by &quot;M:&quot; prefix</p><dl><dt>parameter r</dt><dd><p>Range.t value to export in a string .</p></dd></dl><dl><dt>returns</dt><dd><p>string representing the content of r Range.t value. *</p></dd></dl></dd></dl></div></body></html>