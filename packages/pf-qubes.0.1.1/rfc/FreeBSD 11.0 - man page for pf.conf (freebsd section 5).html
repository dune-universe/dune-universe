<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html dir="ltr" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" /> 

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="keywords" content="pf.conf,freebsd,man,quot,packet,interface,pass,address,anchor,number" />
<meta name="description" content="pf.conf(5) - packet filter configuration file. - pf.conf(5) man page - FreeBSD 11.0 - Unix Commands"/>



<!-- CSS Stylesheet -->






<!-- / CSS Stylesheet -->






<style type="text/css"> pre {font-family:courier;font-size:16px} </style>

<title>FreeBSD 11.0 -  man page for pf.conf (freebsd section 5) - Unix & Linux Commands</title>

</head>
<body>


<!-- content table -->
<!-- open content container -->

<div align="center">
	<div class="page" style="width:100%; text-align:left">
		<div style="padding:0px 25px 0px 25px" align="left">






<br />
<!-- / PAGENAV POPUP -->

</table>
 	
<!-- breadcrumb, login, pm info -->
<table class="tborder" cellpadding="6" cellspacing="1" border="0" width="100%" align="center">

<tr  border="0">




        
       
	
	<td class="alt1" width="100%" border="0">
       

		
			<table cellpadding="0" cellspacing="0" border="0">
			<tr valign="center">
         <td>&nbsp;</td>

				<td>

<a href="#" onclick="history.back(1); return false;"></a></td>

				<td>&nbsp;</td>
                                <td>&nbsp;</td>
				<td width="100%"><div class="navbar" style="font-size:14pt"></div> <div class="navbar" style="font-size:10pt"></div> 
</td>

			</tr>
			<tr>
				<td class="navbar" style="font-size:10pt; padding-top:1px" colspan="3">

<!--
<a href="/man-page/freebsd/5/pf.conf/">

-->


 <!-- <strong>
	<span itemprop="title">Man Pages</span>
</strong> -->
</td>
			</tr>
			</table>
		

	</td>











	<td class="alt2" nowrap="nowrap" style="padding:0px">
		<!-- login form -->
		<form action="login.php?do=login" method="post" onsubmit="md5hash(vb_login_password, vb_login_md5password, vb_login_md5password_utf, 0)">
		<table cellpadding="0" cellspacing="3" border="0">
		<tr>
			<td class="smallfont" style="white-space: nowrap;"><label for="navbar_username">Member Name</label></td>
			<td><input type="text" class="bginput" style="font-size: 11px" name="vb_login_username" id="navbar_username" size="10" accesskey="u" tabindex="101" value="Member Name" onfocus="if (this.value == 'Member Name') this.value = '';" /></td>
			<td class="smallfont" nowrap="nowrap"><label for="cb_cookieuser_navbar"><input type="checkbox" name="cookieuser" value="1" tabindex="103" id="cb_cookieuser_navbar" accesskey="c" />Remember Me?</label></td>
		</tr>
		<tr>
			<td class="smallfont"><label for="navbar_password">Password</label></td>
			<td><input type="password" class="bginput" style="font-size: 11px" name="vb_login_password" id="navbar_password" size="10" tabindex="102" /></td>
			<td><input type="submit" class="button" value="Log in" tabindex="104" title="Enter your username and password in the boxes provided to login, or click the 'register' button to create a profile for yourself." accesskey="s" /></td>
		</tr>

		</table>
		<input type="hidden" name="s" value="a6b8b4f72fe3673edf5497093bbc858f" />
		<input type="hidden" name="securitytoken" value="guest" />
		<input type="hidden" name="do" value="login" />
		<input type="hidden" name="vb_login_md5password" />
		<input type="hidden" name="vb_login_md5password_utf" />
		</form>
		<!-- / login form -->
	</td>







</tr>
</table>
<!-- / breadcrumb, login, pm info -->

<!-- nav buttons bar -->
<div class="tborder" style="padding:1px; border-top-width:0px">
	<table cellpadding="0" cellspacing="0" border="0" width="100%" align="center">
	<tr align="center">
                <td class="vbmenu_control">
		</td>         

<!-- added by neo -->

<td class="vbmenu_control"><a href="/search.php" rel="nofollow">Search Forums</a></td>



                
		
			<td class="vbmenu_control"><a href="register.php?s=a6b8b4f72fe3673edf5497093bbc858f" rel="nofollow">Register</a></td>
		


		<td class="vbmenu_control">
				<td class="vbmenu_control"><a href="search.php?s=a6b8b4f72fe3673edf5497093bbc858f&amp;do=getdaily" accesskey="2" rel="nofollow">Today's Posts</a></td>

		</tr>
	</table>
</div>
<!-- / nav buttons bar -->

<br />






<!-- NAVBAR POPUP MENUS -->

	
	<!-- header quick search form -->
	<div class="vbmenu_popup" id="navbar_search_menu" style="display:none" align="left">
		<table cellpadding="4" cellspacing="1" border="0">
		<tr>
			<td class="thead">Search Forums</td>
		</tr>
		<tr>
			<td class="vbmenu_option" title="nohilite">
				<form action="search.php?do=process" method="post">

					<input type="hidden" name="do" value="process" />
					<input type="hidden" name="quicksearch" value="1" />
					<input type="hidden" name="childforums" value="1" />
					<input type="hidden" name="exactname" value="1" />
					<input type="hidden" name="s" value="a6b8b4f72fe3673edf5497093bbc858f" />
					<input type="hidden" name="securitytoken" value="guest" />
					<div><input type="text" class="bginput" name="query" size="25" tabindex="1001" /><input type="submit" class="button" value="Go" tabindex="1004" /></div>
					<div style="margin-top:6px">
						<label for="rb_nb_sp0"><input type="radio" name="showposts" value="0" id="rb_nb_sp0" tabindex="1002" checked="checked" />Show Threads</label>
						&nbsp;
						<label for="rb_nb_sp1"><input type="radio" name="showposts" value="1" id="rb_nb_sp1" tabindex="1003" />Show Posts</label>
					</div>
				</form>
			</td>
		</tr>
                 <tr>
		</tr>
		
		<tr>
		</tr>
		
		<tr>
		</tr>

</tr>
		</table>
	</div>
	<!-- / header quick search form -->
	

	
<!-- / NAVBAR POPUP MENUS -->

<!-- PAGENAV POPUP -->
	<div class="vbmenu_popup" id="pagenav_menu" style="display:none">
		<table cellpadding="4" cellspacing="1" border="0">
		<tr>
			<td class="thead" nowrap="nowrap">Go to Page...</td>
		</tr>
		<tr>
			<td class="vbmenu_option" title="nohilite">
			<form action="index.php" method="get" onsubmit="return this.gotopage()" id="pagenav_form">
				<input type="text" class="bginput" id="pagenav_itxt" style="font-size:11px" size="4" />
				<input type="button" class="button" id="pagenav_ibtn" value="Go" />
			</form>
			</td>
		</tr>


</tr>

		</table>

	</div>
<!-- / PAGENAV POPUP -->



<p>












<center>
<table width="100%">
<tr>
<td  width="50%" align="center">
<!-- UNIX_ZONE_1_300x250 -->
<div id='div-gpt-ad-1356748021945-6' style='width:300px; height:250px;'>
<script type='text/javascript'>
googletag.cmd.push(function() { googletag.display('div-gpt-ad-1356748021945-6'); });
</script>
</div>
</td>

<td width="50%" align="center">
<!-- UNIX_ZONE_2_300x250 -->
<div id='div-gpt-ad-1356748021945-7' style='width:300px; height:250px;'>
<script type='text/javascript'>
googletag.cmd.push(function() { googletag.display('div-gpt-ad-1356748021945-7'); });
</script>
</div>
</td>
</tr>
</table>
</center>
<br/>


<table class="tborder" cellpadding="$stylevar[cellpadding]" cellspacing="$stylevar[cellspacing]"  width="100%" align="center"><tr class="alt1"><td><center><h1>
					- man page for pf.conf (freebsd section 5)</h1></center></td></tr></table>


<p>
<!-- Body Code -->
<table class="tborder" cellpadding="6" cellspacing="1" border="0" width="100%" align="center">
	<tr>
		<td class="tcat">Linux & Unix Commands - Search Man Pages</td>
	</tr>
	<tr align="center">
		<td class="alt1" align="left">
			<div>
  
<table width="100%">
<tr>
<td width="50%">
    <b>Man Page or Keyword Search: </b><input type="text" name="query"
        size="20" value="" maxlength="20" />

    &nbsp;<input type="submit" value="Submit"/>
</td>
<td width="50%">
<input name="apropos" value="0" type="radio" checked>
<select name="section">
<option value="0" >All Sections</option>
<option value="1" >1 - General Commands</option>
<option value="1m" >1m - System Admin</option>
<option value="2" >2 - System Calls</option>
<option value="3" >3 - Subroutines</option>
<option value="4" >4 - Special Files</option>
<option value="5" selected="selected">5 - File Formats</option>
<option value="6" >6 - Games</option>
<option value="7" >7 - Macros and Conventions</option>
<option value="8" >8 - Maintenance Commands</option>
<option value="9" >9 - Kernel Interface</option>
<option value="n" >N - New Commands</option>
</select>  
</td>
</tr>
<tr>
<td width="50%">
<b>Select Man Page Set:</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <select name="os">

<option value="linux" >Linux 2.6</option>
<option value="redhat" >RedHat 9 (Linux i386)</option>
<option value="debian" >Debian 7.7</option>
<option value="suse" >SuSE 11.3</option>
<option value="centos" >CentOS 7.0</option>
<option value="sunos" >SunOS 5.10</option>
<option value="opensolaris" >OpenSolaris 2009.06</option>
<option value="bsd" >BSD 2.11</option>
<option value="freebsd" selected="selected">FreeBSD 11.0</option>
<option value="netbsd" >NetBSD 6.1.5</option>
<option value="osx" >OSX 10.6.2</option>
<option value="opendarwin" >OpenDarwin 7.2.1</option>
<option value="ultrix" >ULTRIX 4.2</option>
<option value="php" >PHP 5.6</option>
<option value="minix" >Minix 2.0</option>
<option value="plan9" >Plan 9</option>
<option value="v7" >Unix Version 7</option>
<option value="osf1" >OSF1 5.1 (alpha)</option>
<option value="posix" >POSIX 1003.1</option>
<option value="x11r4" >X11R7.4</option>
<option value="xfree86" >XFree86 4.7.0</option>
<option value="All" >all unix.com man page sets</option>



    </select>
       
</td>
<td width="50%">
<input name="apropos" value="1"  type="radio" >
</td>
</tr>
</table>
</form>
<p>
			</div>
		</td>
	</tr>
</table>



<P>
<table class="tborder" cellpadding="6" cellspacing="1"  width="100%" align="center">
<tr>



</tr>


<tr>
<td class="alt1">
                <br/>
                


<table>
<tr>
<td width="10%">           </td>
<td width="80%">
<pre><a  style="font-size:1.2em;"  href="/man-page/freebsd/5/PF.CONF/">PF.CONF(5)</a> 			     BSD File Formats Manual			         <a  style="font-size:1.2em;"  href="/man-page/freebsd/5/PF.CONF/">PF.CONF(5)</a> 

<b>NAME</b>
     pf.conf <b><i>--</i></b> packet filter configuration file

<b>DESCRIPTION</b>
     The   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  packet filter modifies, drops or passes packets according to rules or definitions
     specified in pf.conf.

<b>STATEMENT ORDER</b>
     There are seven types of statements in pf.conf:

     Macros
	   User-defined variables may be defined and used later, simplifying the configuration
	   file.  Macros must be defined before they are referenced in pf.conf.

     Tables
	   Tables provide a mechanism for increasing the performance and flexibility of rules
	   with large numbers of source or destination addresses.

     Options
	   Options tune the behaviour of the packet filtering engine.

     Traffic Normalization (e.g. scrub)
	   Traffic normalization protects internal machines against inconsistencies in Internet
	   protocols and implementations.

     Queueing
	   Queueing provides rule-based bandwidth control.

     Translation (Various forms of NAT)
	   Translation rules specify how addresses are to be mapped or redirected to other
	   addresses.

     Packet Filtering
	   Packet filtering provides rule-based blocking or passing of packets.

     With the exception of macros and tables, the types of statements should be grouped and
     appear in pf.conf in the order shown above, as this matches the operation of the underlying
     packet filtering engine.  By default   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/pfctl/">pfctl(8)</a>  enforces this order (see set require-order
     below).

     Comments can be put anywhere in the file using a hash mark ('#'), and extend to the end of
     the current line.

     Additional configuration files can be included with the include keyword, for example:

	   include &quot;/etc/pf/sub.filter.conf&quot;

<b>MACROS</b>
     Macros can be defined that will later be expanded in context.  Macro names must start with a
     letter, and may contain letters, digits and underscores.  Macro names may not be reserved
     words (for example pass, in, out).  Macros are not expanded inside quotes.

     For example,

	   ext_if = &quot;kue0&quot;
	   all_ifs = &quot;{&quot; $ext_if lo0 &quot;}&quot;
	   pass out on $ext_if from any to any
	   pass in  on $ext_if proto tcp from any to any port 25

<b>TABLES</b>
     Tables are named structures which can hold a collection of addresses and networks.  Lookups
     against tables in   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  are relatively fast, making a single rule with tables much more
     efficient, in terms of processor usage and memory consumption, than a large number of rules
     which differ only in IP address (either created explicitly or automatically by rule expan-
     sion).

     Tables can be used as the source or destination of filter rules, scrub rules or translation
     rules such as nat or rdr (see below for details on the various rule types).  Tables can also
     be used for the redirect address of nat and rdr rules and in the routing options of filter
     rules, but only for round-robin pools.

     Tables can be defined with any of the following   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/pfctl/">pfctl(8)</a>  mechanisms.  As with macros,
     reserved words may not be used as table names.

     manually  Persistent tables can be manually created with the add or replace option of
	         <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/pfctl/">pfctl(8)</a> , before or after the ruleset has been loaded.

     pf.conf   Table definitions can be placed directly in this file, and loaded at the same time
	       as other rules are loaded, atomically.  Table definitions inside pf.conf use the
	       table statement, and are especially useful to define non-persistent tables.  The
	       contents of a pre-existing table defined without a list of addresses to initialize
	       it is not altered when pf.conf is loaded.  A table initialized with the empty
	       list, { }, will be cleared on load.

     Tables may be defined with the following attributes:

     persist  The persist flag forces the kernel to keep the table even when no rules refer to
	      it.  If the flag is not set, the kernel will automatically remove the table when
	      the last rule referring to it is flushed.

     const    The const flag prevents the user from altering the contents of the table once it
	      has been created.  Without that flag,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/pfctl/">pfctl(8)</a>  can be used to add or remove
	      addresses from the table at any time, even when running with   <a  style="font-size:1.2em;"  href="/man-page/freebsd/7/securelevel/">securelevel(7)</a>  = 2.

     counters
	      The counters flag enables per-address packet and byte counters which can be dis-
	      played with   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/pfctl/">pfctl(8)</a> .

     For example,

	   table &lt;private&gt; const { 10/8, 172.16/12, 192.168/16 }
	   table &lt;badhosts&gt; persist
	   block on fxp0 from { &lt;private&gt;, &lt;badhosts&gt; } to any

     creates a table called private, to hold RFC 1918 private network blocks, and a table called
     badhosts, which is initially empty.  A filter rule is set up to block all traffic coming
     from addresses listed in either table.  The private table cannot have its contents changed
     and the badhosts table will exist even when no active filter rules reference it.  Addresses
     may later be added to the badhosts table, so that traffic from these hosts can be blocked by
     using

	   # pfctl <b><i>-t</i></b> badhosts <b><i>-Tadd</i></b> 204.92.77.111

     A table can also be initialized with an address list specified in one or more external
     files, using the following syntax:

	   table &lt;spam&gt; persist file &quot;/etc/spammers&quot; file &quot;/etc/openrelays&quot;
	   block on fxp0 from &lt;spam&gt; to any

     The files /etc/spammers and /etc/openrelays list IP addresses, one per line.  Any lines
     beginning with a # are treated as comments and ignored.  In addition to being specified by
     IP address, hosts may also be specified by their hostname.  When the resolver is called to
     add a hostname to a table, all resulting IPv4 and IPv6 addresses are placed into the table.
     IP addresses can also be entered in a table by specifying a valid interface name, a valid
     interface group or the self keyword, in which case all addresses assigned to the inter-
     face(s) will be added to the table.

<b>OPTIONS</b>
       <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  may be tuned for various situations using the set command.

     set timeout

	   interval   Interval between purging expired states and fragments.
	   frag       Seconds before an unassembled fragment is expired.
	   src.track  Length of time to retain a source tracking entry after the last state
		      expires.

	   When a packet matches a stateful connection, the seconds to live for the connection
	   will be updated to that of the proto.modifier which corresponds to the connection
	   state.  Each packet which matches this state will reset the TTL.  Tuning these values
	   may improve the performance of the firewall at the risk of dropping valid idle connec-
	   tions.

	   tcp.first
		 The state after the first packet.
	   tcp.opening
		 The state before the destination host ever sends a packet.
	   tcp.established
		 The fully established state.
	   tcp.closing
		 The state after the first FIN has been sent.
	   tcp.finwait
		 The state after both FINs have been exchanged and the connection is closed.
		 Some hosts (notably web servers on Solaris) send TCP packets even after closing
		 the connection.  Increasing tcp.finwait (and possibly tcp.closing) can prevent
		 blocking of such packets.
	   tcp.closed
		 The state after one endpoint sends an RST.

	   ICMP and UDP are handled in a fashion similar to TCP, but with a much more limited set
	   of states:

	   udp.first
		 The state after the first packet.
	   udp.single
		 The state if the source host sends more than one packet but the destination host
		 has never sent one back.
	   udp.multiple
		 The state if both hosts have sent packets.
	   icmp.first
		 The state after the first packet.
	   icmp.error
		 The state after an ICMP error came back in response to an ICMP packet.

	   Other protocols are handled similarly to UDP:

	   other.first
	   other.single
	   other.multiple

	   Timeout values can be reduced adaptively as the number of state table entries grows.

	   adaptive.start
		 When the number of state entries exceeds this value, adaptive scaling begins.
		 All timeout values are scaled linearly with factor (adaptive.end - number of
		 states) / (adaptive.end - adaptive.start).
	   adaptive.end
		 When reaching this number of state entries, all timeout values become zero,
		 effectively purging all state entries immediately.  This value is used to define
		 the scale factor, it should not actually be reached (set a lower state limit,
		 see below).

	   Adaptive timeouts are enabled by default, with an adaptive.start value equal to 60% of
	   the state limit, and an adaptive.end value equal to 120% of the state limit.  They can
	   be disabled by setting both adaptive.start and adaptive.end to 0.

	   The adaptive timeout values can be defined both globally and for each rule.	When used
	   on a per-rule basis, the values relate to the number of states created by the rule,
	   otherwise to the total number of states.

	   For example:

		 set timeout tcp.first 120
		 set timeout tcp.established 86400
		 set timeout { adaptive.start 6000, adaptive.end 12000 }
		 set limit states 10000

	   With 9000 state table entries, the timeout values are scaled to 50% (tcp.first 60,
	   tcp.established 43200).

     set loginterface
	   Enable collection of packet and byte count statistics for the given interface or
	   interface group.  These statistics can be viewed using

		 # pfctl <b><i>-s</i></b> info

	   In this example   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  collects statistics on the interface named dc0:

		 set loginterface dc0

	   One can disable the loginterface using:

		 set loginterface none

     set limit
	   Sets hard limits on the memory pools used by the packet filter.  See   <a  style="font-size:1.2em;"  href="/man-page/freebsd/9/zone/">zone(9)</a>  for an
	   explanation of memory pools.

	   For example,

		 set limit states 20000

	   sets the maximum number of entries in the memory pool used by state table entries
	   (generated by pass rules which do not specify no state) to 20000.  Using

		 set limit frags 20000

	   sets the maximum number of entries in the memory pool used for fragment reassembly
	   (generated by scrub rules) to 20000.  Using

		 set limit src-nodes 2000

	   sets the maximum number of entries in the memory pool used for tracking source IP
	   addresses (generated by the sticky-address and src.track options) to 2000.  Using

		 set limit tables 1000
		 set limit table-entries 100000

	   sets limits on the memory pools used by tables.  The first limits the number of tables
	   that can exist to 1000.  The second limits the overall number of addresses that can be
	   stored in tables to 100000.

	   Various limits can be combined on a single line:

		 set limit { states 20000, frags 20000, src-nodes 2000 }

     set ruleset-optimization
	   none      Disable the ruleset optimizer.
	   basic     Enable basic ruleset optimization.  This is the default behaviour.  Basic
		     ruleset optimization does four things to improve the performance of ruleset
		     evaluations:

		     1.   remove duplicate rules
		     2.   remove rules that are a subset of another rule
		     3.   combine multiple rules into a table when advantageous
		     4.   re-order the rules to improve evaluation performance

	   profile   Uses the currently loaded ruleset as a feedback profile to tailor the order-
		     ing of quick rules to actual network traffic.

	   It is important to note that the ruleset optimizer will modify the ruleset to improve
	   performance.  A side effect of the ruleset modification is that per-rule accounting
	   statistics will have different meanings than before.  If per-rule accounting is impor-
	   tant for billing purposes or whatnot, either the ruleset optimizer should not be used
	   or a label field should be added to all of the accounting rules to act as optimization
	   barriers.

	   Optimization can also be set as a command-line argument to   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/pfctl/">pfctl(8)</a> , overriding the
	   settings in pf.conf.

     set optimization
	   Optimize state timeouts for one of the following network environments:

	   normal
		 A normal network environment.	Suitable for almost all networks.
	   high-latency
		 A high-latency environment (such as a satellite connection).
	   satellite
		 Alias for high-latency.
	   aggressive
		 Aggressively expire connections.  This can greatly reduce the memory usage of
		 the firewall at the cost of dropping idle connections early.
	   conservative
		 Extremely conservative settings.  Avoid dropping legitimate connections at the
		 expense of greater memory utilization (possibly much greater on a busy network)
		 and slightly increased processor utilization.

	   For example:

		 set optimization aggressive

     set block-policy
	   The block-policy option sets the default behaviour for the packet block action:

	   drop      Packet is silently dropped.
	   return    A TCP RST is returned for blocked TCP packets, an ICMP UNREACHABLE is
		     returned for blocked UDP packets, and all other packets are silently
		     dropped.

	   For example:

		 set block-policy return

     set state-policy
	   The state-policy option sets the default behaviour for states:

	   if-bound	States are bound to interface.
	   floating	States can match packets on any interfaces (the default).

	   For example:

		 set state-policy if-bound

     set state-defaults
	   The state-defaults option sets the state options for states created from rules without
	   an explicit keep state.  For example:

		 set state-defaults pflow, no-sync

     set hostid
	   The 32-bit hostid identifies this firewall's state table entries to other firewalls in
	   a   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pfsync/">pfsync(4)</a>  failover cluster.  By default the hostid is set to a pseudo-random value,
	   however it may be desirable to manually configure it, for example to more easily iden-
	   tify the source of state table entries.

		 set hostid 1

	   The hostid may be specified in either decimal or hexadecimal.

     set require-order
	   By default   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/pfctl/">pfctl(8)</a>  enforces an ordering of the statement types in the ruleset to:
	   options, normalization, queueing, translation, filtering.  Setting this option to no
	   disables this enforcement.  There may be non-trivial and non-obvious implications to
	   an out of order ruleset.  Consider carefully before disabling the order enforcement.

     set fingerprints
	   Load fingerprints of known operating systems from the given filename.  By default fin-
	   gerprints of known operating systems are automatically loaded from   <a  style="font-size:1.2em;"  href="/man-page/freebsd/5/pf.os/">pf.os(5)</a>  in /etc
	   but can be overridden via this option.  Setting this option may leave a small period
	   of time where the fingerprints referenced by the currently active ruleset are incon-
	   sistent until the new ruleset finishes loading.

	   For example:

		 set fingerprints &quot;/etc/pf.os.devel&quot;

     set skip on &lt;ifspec&gt;
	   List interfaces for which packets should not be filtered.  Packets passing in or out
	   on such interfaces are passed as if pf was disabled, i.e. pf does not process them in
	   any way.  This can be useful on loopback and other virtual interfaces, when packet
	   filtering is not desired and can have unexpected effects.  For example:

		 set skip on lo0

     set debug
	   Set the debug level to one of the following:

	   none 	 Don't generate debug messages.
	   urgent	 Generate debug messages only for serious errors.
	   misc 	 Generate debug messages for various errors.
	   loud 	 Generate debug messages for common conditions.

<b>TRAFFIC NORMALIZATION</b>
     Traffic normalization is used to sanitize packet content in such a way that there are no
     ambiguities in packet interpretation on the receiving side.  The normalizer does IP fragment
     reassembly to prevent attacks that confuse intrusion detection systems by sending overlap-
     ping IP fragments.  Packet normalization is invoked with the scrub directive.

     scrub has the following options:

     no-df
	   Clears the dont-fragment bit from a matching IP packet.  Some operating systems are
	   known to generate fragmented packets with the dont-fragment bit set.  This is particu-
	   larly true with NFS.  Scrub will drop such fragmented dont-fragment packets unless
	   no-df is specified.

	   Unfortunately some operating systems also generate their dont-fragment packets with a
	   zero IP identification field.  Clearing the dont-fragment bit on packets with a zero
	   IP ID may cause deleterious results if an upstream router later fragments the packet.
	   Using the random-id modifier (see below) is recommended in combination with the no-df
	   modifier to ensure unique IP identifiers.

     min-ttl &lt;number&gt;
	   Enforces a minimum TTL for matching IP packets.

     max-mss &lt;number&gt;
	   Enforces a maximum MSS for matching TCP packets.

     set-tos &lt;string&gt; | &lt;number&gt;
	   Enforces a TOS for matching IP packets.  TOS may be given as one of lowdelay,
	   throughput, reliability, or as either hex or decimal.

     random-id
	   Replaces the IP identification field with random values to compensate for predictable
	   values generated by many hosts.  This option only applies to packets that are not
	   fragmented after the optional fragment reassembly.

     fragment reassemble
	   Using scrub rules, fragments can be reassembled by normalization.  In this case, frag-
	   ments are buffered until they form a complete packet, and only the completed packet is
	   passed on to the filter.  The advantage is that filter rules have to deal only with
	   complete packets, and can ignore fragments.	The drawback of caching fragments is the
	   additional memory cost.  But the full reassembly method is the only method that cur-
	   rently works with NAT.  This is the default behavior of a scrub rule if no fragmenta-
	   tion modifier is supplied.

     fragment crop
	   The default fragment reassembly method is expensive, hence the option to crop is pro-
	   vided.  In this case,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  will track the fragments and cache a small range descrip-
	   tor.  Duplicate fragments are dropped and overlaps are cropped.  Thus data will only
	   occur once on the wire with ambiguities resolving to the first occurrence.  Unlike the
	   fragment reassemble modifier, fragments are not buffered, they are passed as soon as
	   they are received.  The fragment crop reassembly mechanism does not yet work with NAT.

     fragment drop-ovl
	   This option is similar to the fragment crop modifier except that all overlapping or
	   duplicate fragments will be dropped, and all further corresponding fragments will be
	   dropped as well.

     reassemble tcp
	   Statefully normalizes TCP connections.  scrub reassemble tcp rules may not have the
	   direction (in/out) specified.  reassemble tcp performs the following normalizations:

	   ttl	    Neither side of the connection is allowed to reduce their IP TTL.  An
		    attacker may send a packet such that it reaches the firewall, affects the
		    firewall state, and expires before reaching the destination host.  reassemble
		    tcp will raise the TTL of all packets back up to the highest value seen on
		    the connection.
	   timestamp modulation
		    Modern TCP stacks will send a timestamp on every TCP packet and echo the
		    other endpoint's timestamp back to them.  Many operating systems will merely
		    start the timestamp at zero when first booted, and increment it several times
		    a second.  The uptime of the host can be deduced by reading the timestamp and
		    multiplying by a constant.	Also observing several different timestamps can
		    be used to count hosts behind a NAT device.  And spoofing TCP packets into a
		    connection requires knowing or guessing valid timestamps.  Timestamps merely
		    need to be monotonically increasing and not derived off a guessable base
		    time.  reassemble tcp will cause scrub to modulate the TCP timestamps with a
		    random number.
	   extended PAWS checks
		    There is a problem with TCP on long fat pipes, in that a packet might get
		    delayed for longer than it takes the connection to wrap its 32-bit sequence
		    space.  In such an occurrence, the old packet would be indistinguishable from
		    a new packet and would be accepted as such.  The solution to this is called
		    PAWS: Protection Against Wrapped Sequence numbers.	It protects against it by
		    making sure the timestamp on each packet does not go backwards.  reassemble
		    tcp also makes sure the timestamp on the packet does not go forward more than
		    the RFC allows.  By doing this,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  artificially extends the security of
		    TCP sequence numbers by 10 to 18 bits when the host uses appropriately ran-
		    domized timestamps, since a blind attacker would have to guess the timestamp
		    as well.

     For example,

	   scrub in on $ext_if all fragment reassemble

     The no option prefixed to a scrub rule causes matching packets to remain unscrubbed, much in
     the same way as drop quick works in the packet filter (see below).  This mechanism should be
     used when it is necessary to exclude specific packets from broader scrub rules.

<b>QUEUEING</b>
     The ALTQ system is currently not available in the GENERIC kernel nor as loadable modules.
     In order to use the herein after called queueing options one has to use a custom built ker-
     nel.  Please refer to   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/altq/">altq(4)</a>  to learn about the related kernel options.

     Packets can be assigned to queues for the purpose of bandwidth control.  At least two decla-
     rations are required to configure queues, and later any packet filtering rule can reference
     the defined queues by name.  During the filtering component of pf.conf, the last referenced
     queue name is where any packets from pass rules will be queued, while for block rules it
     specifies where any resulting ICMP or TCP RST packets should be queued.  The scheduler
     defines the algorithm used to decide which packets get delayed, dropped, or sent out immedi-
     ately.  There are three schedulers currently supported.

     cbq   Class Based Queueing.  Queues attached to an interface build a tree, thus each queue
	   can have further child queues.  Each queue can have a priority and a bandwidth
	   assigned.  Priority mainly controls the time packets take to get sent out, while
	   bandwidth has primarily effects on throughput.  cbq achieves both partitioning and
	   sharing of link bandwidth by hierarchically structured classes.  Each class has its
	   own queue and is assigned its share of bandwidth.  A child class can borrow bandwidth
	   from its parent class as long as excess bandwidth is available (see the option borrow,
	   below).

     priq  Priority Queueing.  Queues are flat attached to the interface, thus, queues cannot
	   have further child queues.  Each queue has a unique priority assigned, ranging from 0
	   to 15.  Packets in the queue with the highest priority are processed first.

     hfsc  Hierarchical Fair Service Curve.  Queues attached to an interface build a tree, thus
	   each queue can have further child queues.  Each queue can have a priority and a
	   bandwidth assigned.	Priority mainly controls the time packets take to get sent out,
	   while bandwidth primarily affects throughput.  hfsc supports both link-sharing and
	   guaranteed real-time services.  It employs a service curve based QoS model, and its
	   unique feature is an ability to decouple delay and bandwidth allocation.

     The interfaces on which queueing should be activated are declared using the altq on declara-
     tion.  altq on has the following keywords:

     &lt;interface&gt;
	   Queueing is enabled on the named interface.

     &lt;scheduler&gt;
	   Specifies which queueing scheduler to use.  Currently supported values are cbq for
	   Class Based Queueing, priq for Priority Queueing and hfsc for the Hierarchical Fair
	   Service Curve scheduler.

     bandwidth &lt;bw&gt;
	   The maximum bitrate for all queues on an interface may be specified using the
	   bandwidth keyword.  The value can be specified as an absolute value or as a percentage
	   of the interface bandwidth.	When using an absolute value, the suffixes b, Kb, Mb, and
	   Gb are used to represent bits, kilobits, megabits, and gigabits per second, respec-
	   tively.  The value must not exceed the interface bandwidth.	If bandwidth is not spec-
	   ified, the interface bandwidth is used (but take note that some interfaces do not know
	   their bandwidth, or can adapt their bandwidth rates).

     qlimit &lt;limit&gt;
	   The maximum number of packets held in the queue.  The default is 50.

     tbrsize &lt;size&gt;
	   Adjusts the size, in bytes, of the token bucket regulator.  If not specified, heuris-
	   tics based on the interface bandwidth are used to determine the size.

     queue &lt;list&gt;
	   Defines a list of subqueues to create on an interface.

     In the following example, the interface dc0 should queue up to 5Mbps in four second-level
     queues using Class Based Queueing.  Those four queues will be shown in a later example.

	   altq on dc0 cbq bandwidth 5Mb queue { std, http, mail, ssh }

     Once interfaces are activated for queueing using the altq directive, a sequence of queue
     directives may be defined.  The name associated with a queue must match a queue defined in
     the altq directive (e.g. mail), or, except for the priq scheduler, in a parent queue decla-
     ration.  The following keywords can be used:

     on &lt;interface&gt;
	   Specifies the interface the queue operates on.  If not given, it operates on all
	   matching interfaces.

     bandwidth &lt;bw&gt;
	   Specifies the maximum bitrate to be processed by the queue.	This value must not
	   exceed the value of the parent queue and can be specified as an absolute value or a
	   percentage of the parent queue's bandwidth.	If not specified, defaults to 100% of the
	   parent queue's bandwidth.  The priq scheduler does not support bandwidth specifica-
	   tion.

     priority &lt;level&gt;
	   Between queues a priority level can be set.	For cbq and hfsc, the range is 0 to 7 and
	   for priq, the range is 0 to 15.  The default for all is 1.  Priq queues with a higher
	   priority are always served first.  Cbq and Hfsc queues with a higher priority are pre-
	   ferred in the case of overload.

     qlimit &lt;limit&gt;
	   The maximum number of packets held in the queue.  The default is 50.

     The scheduler can get additional parameters with &lt;scheduler&gt; (&lt;parameters&gt;).  Parameters are
     as follows:

     default	 Packets not matched by another queue are assigned to this one.  Exactly one
		 default queue is required.

     red	 Enable RED (Random Early Detection) on this queue.  RED drops packets with a
		 probability proportional to the average queue length.

     rio	 Enables RIO on this queue.  RIO is RED with IN/OUT, thus running RED two times
		 more than RIO would achieve the same effect.  RIO is currently not supported in
		 the GENERIC kernel.

     ecn	 Enables ECN (Explicit Congestion Notification) on this queue.	ECN implies RED.

     The cbq scheduler supports an additional option:

     borrow	 The queue can borrow bandwidth from the parent.

     The hfsc scheduler supports some additional options:

     realtime &lt;sc&gt;
		 The minimum required bandwidth for the queue.

     upperlimit &lt;sc&gt;
		 The maximum allowed bandwidth for the queue.

     linkshare &lt;sc&gt;
		 The bandwidth share of a backlogged queue.

     &lt;sc&gt; is an acronym for service curve.

     The format for service curve specifications is (m1, d, m2).  m2 controls the bandwidth
     assigned to the queue.  m1 and d are optional and can be used to control the initial band-
     width assignment.	For the first d milliseconds the queue gets the bandwidth given as m1,
     afterwards the value given in m2.

     Furthermore, with cbq and hfsc, child queues can be specified as in an altq declaration,
     thus building a tree of queues using a part of their parent's bandwidth.

     Packets can be assigned to queues based on filter rules by using the queue keyword.  Nor-
     mally only one queue is specified; when a second one is specified it will instead be used
     for packets which have a TOS of lowdelay and for TCP ACKs with no data payload.

     To continue the previous example, the examples below would specify the four referenced
     queues, plus a few child queues.  Interactive   <a  style="font-size:1.2em;"  href="/man-page/freebsd/1/ssh/">ssh(1)</a>  sessions get priority over bulk trans-
     fers like   <a  style="font-size:1.2em;"  href="/man-page/freebsd/1/scp/">scp(1)</a>  and   <a  style="font-size:1.2em;"  href="/man-page/freebsd/1/sftp/">sftp(1)</a> .  The queues may then be referenced by filtering rules (see
     PACKET FILTERING below).

     queue std bandwidth 10% cbq(default)
     queue http bandwidth 60% priority 2 cbq(borrow red) \
	   { employees, developers }
     queue  developers bandwidth 75% cbq(borrow)
     queue  employees bandwidth 15%
     queue mail bandwidth 10% priority 0 cbq(borrow ecn)
     queue ssh bandwidth 20% cbq(borrow) { ssh_interactive, ssh_bulk }
     queue  ssh_interactive bandwidth 50% priority 7 cbq(borrow)
     queue  ssh_bulk bandwidth 50% priority 0 cbq(borrow)

     block return out on dc0 inet all queue std
     pass out on dc0 inet proto tcp from $developerhosts to any port 80 \
	   queue developers
     pass out on dc0 inet proto tcp from $employeehosts to any port 80 \
	   queue employees
     pass out on dc0 inet proto tcp from any to any port 22 \
	   queue(ssh_bulk, ssh_interactive)
     pass out on dc0 inet proto tcp from any to any port 25 \
	   queue mail

<b>TRANSLATION</b>
     Translation rules modify either the source or destination address of the packets associated
     with a stateful connection.  A stateful connection is automatically created to track packets
     matching such a rule as long as they are not blocked by the filtering section of pf.conf.
     The translation engine modifies the specified address and/or port in the packet, recalcu-
     lates IP, TCP and UDP checksums as necessary, and passes it to the packet filter for evalua-
     tion.

     Since translation occurs before filtering the filter engine will see packets as they look
     after any addresses and ports have been translated.  Filter rules will therefore have to
     filter based on the translated address and port number.  Packets that match a translation
     rule are only automatically passed if the pass modifier is given, otherwise they are still
     subject to block and pass rules.

     The state entry created permits   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  to keep track of the original address for traffic
     associated with that state and correctly direct return traffic for that connection.

     Various types of translation are possible with pf:

     binat
	   A binat rule specifies a bidirectional mapping between an external IP netblock and an
	   internal IP netblock.

     nat   A nat rule specifies that IP addresses are to be changed as the packet traverses the
	   given interface.  This technique allows one or more IP addresses on the translating
	   host to support network traffic for a larger range of machines on an &quot;inside&quot; network.
	   Although in theory any IP address can be used on the inside, it is strongly recom-
	   mended that one of the address ranges defined by RFC 1918 be used.  These netblocks
	   are:

	   10.0.0.0 - 10.255.255.255 (all of net 10, i.e., 10/8)
	   172.16.0.0 - 172.31.255.255 (i.e., 172.16/12)
	   192.168.0.0 - 192.168.255.255 (i.e., 192.168/16)

     rdr   The packet is redirected to another destination and possibly a different port.  rdr
	   rules can optionally specify port ranges instead of single ports.  rdr ... port
	   2000:2999 -&gt; ... port 4000 redirects ports 2000 to 2999 (inclusive) to port 4000.  rdr
	   ... port 2000:2999 -&gt; ... port 4000:* redirects port 2000 to 4000, 2001 to 4001, ...,
	   2999 to 4999.

     In addition to modifying the address, some translation rules may modify source or destina-
     tion ports for   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/tcp/">tcp(4)</a>  or   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/udp/">udp(4)</a>  connections; implicitly in the case of nat rules and explic-
     itly in the case of rdr rules.  Port numbers are never translated with a binat rule.

     Evaluation order of the translation rules is dependent on the type of the translation rules
     and of the direction of a packet.	binat rules are always evaluated first.  Then either the
     rdr rules are evaluated on an inbound packet or the nat rules on an outbound packet.  Rules
     of the same type are evaluated in the same order in which they appear in the ruleset.  The
     first matching rule decides what action is taken.

     The no option prefixed to a translation rule causes packets to remain untranslated, much in
     the same way as drop quick works in the packet filter (see below).  If no rule matches the
     packet it is passed to the filter engine unmodified.

     Translation rules apply only to packets that pass through the specified interface, and if no
     interface is specified, translation is applied to packets on all interfaces.  For instance,
     redirecting port 80 on an external interface to an internal web server will only work for
     connections originating from the outside.	Connections to the address of the external inter-
     face from local hosts will not be redirected, since such packets do not actually pass
     through the external interface.  Redirections cannot reflect packets back through the inter-
     face they arrive on, they can only be redirected to hosts connected to different interfaces
     or to the firewall itself.

     Note that redirecting external incoming connections to the loopback address, as in

	   rdr on ne3 inet proto tcp to port smtp -&gt; 127.0.0.1 port spamd

     will effectively allow an external host to connect to daemons bound solely to the loopback
     address, circumventing the traditional blocking of such connections on a real interface.
     Unless this effect is desired, any of the local non-loopback addresses should be used as re-
     direction target instead, which allows external connections only to daemons bound to this
     address or not bound to any address.

     See TRANSLATION EXAMPLES below.

<b>PACKET FILTERING</b>
       <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  has the ability to block and pass packets based on attributes of their layer 3 (see
       <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/ip/">ip(4)</a>  and   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/ip6/">ip6(4)</a> ) and layer 4 (see   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/icmp/">icmp(4)</a> ,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/icmp6/">icmp6(4)</a> ,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/tcp/">tcp(4)</a> ,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/udp/">udp(4)</a> ) headers.  In addition,
     packets may also be assigned to queues for the purpose of bandwidth control.

     For each packet processed by the packet filter, the filter rules are evaluated in sequential
     order, from first to last.  The last matching rule decides what action is taken.  If no rule
     matches the packet, the default action is to pass the packet.

     The following actions can be used in the filter:

     block
	   The packet is blocked.  There are a number of ways in which a block rule can behave
	   when blocking a packet.  The default behaviour is to drop packets silently, however
	   this can be overridden or made explicit either globally, by setting the block-policy
	   option, or on a per-rule basis with one of the following options:

	   drop  The packet is silently dropped.
	   return-rst
		 This applies only to   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/tcp/">tcp(4)</a>  packets, and issues a TCP RST which closes the con-
		 nection.
	   return-icmp
	   return-icmp6
		 This causes ICMP messages to be returned for packets which match the rule.  By
		 default this is an ICMP UNREACHABLE message, however this can be overridden by
		 specifying a message as a code or number.
	   return
		 This causes a TCP RST to be returned for   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/tcp/">tcp(4)</a>  packets and an ICMP UNREACHABLE
		 for UDP and other packets.

	   Options returning ICMP packets currently have no effect if   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  operates on a
	     <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/if_bridge/">if_bridge(4)</a> , as the code to support this feature has not yet been implemented.

	   The simplest mechanism to block everything by default and only pass packets that match
	   explicit rules is specify a first filter rule of:

		 block all

     pass  The packet is passed; state is created unless the no state option is specified.

     By default   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  filters packets statefully; the first time a packet matches a pass rule, a
     state entry is created; for subsequent packets the filter checks whether the packet matches
     any state.  If it does, the packet is passed without evaluation of any rules.  After the
     connection is closed or times out, the state entry is automatically removed.

     This has several advantages.  For TCP connections, comparing a packet to a state involves
     checking its sequence numbers, as well as TCP timestamps if a scrub reassemble tcp rule
     applies to the connection.  If these values are outside the narrow windows of expected val-
     ues, the packet is dropped.  This prevents spoofing attacks, such as when an attacker sends
     packets with a fake source address/port but does not know the connection's sequence numbers.
     Similarly,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  knows how to match ICMP replies to states.  For example,

	   pass out inet proto icmp all icmp-type echoreq

     allows echo requests (such as those created by   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/ping/">ping(8)</a> ) out statefully, and matches incoming
     echo replies correctly to states.

     Also, looking up states is usually faster than evaluating rules.  If there are 50 rules, all
     of them are evaluated sequentially in O(n).  Even with 50000 states, only 16 comparisons are
     needed to match a state, since states are stored in a binary search tree that allows
     searches in O(log2 n).

     Furthermore, correct handling of ICMP error messages is critical to many protocols, particu-
     larly TCP.    <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  matches ICMP error messages to the correct connection, checks them against
     connection parameters, and passes them if appropriate.  For example if an ICMP source quench
     message referring to a stateful TCP connection arrives, it will be matched to the state and
     get passed.

     Finally, state tracking is required for nat, binat and rdr rules, in order to track address
     and port translations and reverse the translation on returning packets.

       <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  will also create state for other protocols which are effectively stateless by nature.
     UDP packets are matched to states using only host addresses and ports, and other protocols
     are matched to states using only the host addresses.

     If stateless filtering of individual packets is desired, the no state keyword can be used to
     specify that state will not be created if this is the last matching rule.	A number of
     parameters can also be set to affect how   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  handles state tracking.  See STATEFUL
     TRACKING OPTIONS below for further details.

<b>PARAMETERS</b>
     The rule parameters specify the packets to which a rule applies.  A packet always comes in
     on, or goes out through, one interface.  Most parameters are optional.  If a parameter is
     specified, the rule only applies to packets with matching attributes.  Certain parameters
     can be expressed as lists, in which case   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/pfctl/">pfctl(8)</a>  generates all needed rule combinations.

     in or out
	   This rule applies to incoming or outgoing packets.  If neither in nor out are speci-
	   fied, the rule will match packets in both directions.

     log   In addition to the action specified, a log message is generated.  Only the packet that
	   establishes the state is logged, unless the no state option is specified.  The logged
	   packets are sent to a   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pflog/">pflog(4)</a>  interface, by default pflog0.  This interface is moni-
	   tored by the   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/pflogd/">pflogd(8)</a>  logging daemon, which dumps the logged packets to the file
	   /var/log/pflog in   <a  style="font-size:1.2em;"  href="/man-page/freebsd/3/pcap/">pcap(3)</a>  binary format.

     log (all)
	   Used to force logging of all packets for a connection.  This is not necessary when no
	   state is explicitly specified.  As with log, packets are logged to   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pflog/">pflog(4)</a> .

     log (user)
	   Logs the UNIX user ID of the user that owns the socket and the PID of the process that
	   has the socket open where the packet is sourced from or destined to (depending on
	   which socket is local).  This is in addition to the normal information logged.

	   Only the first packet logged via log (all, user) will have the user credentials logged
	   when using stateful matching.

     log (to &lt;interface&gt;)
	   Send logs to the specified   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pflog/">pflog(4)</a>  interface instead of pflog0.

     quick
	   If a packet matches a rule which has the quick option set, this rule is considered the
	   last matching rule, and evaluation of subsequent rules is skipped.

     on &lt;interface&gt;
	   This rule applies only to packets coming in on, or going out through, this particular
	   interface or interface group.  For more information on interface groups, see the group
	   keyword in   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/ifconfig/">ifconfig(8)</a> .

     &lt;af&gt;  This rule applies only to packets of this address family.  Supported values are inet
	   and inet6.

     proto &lt;protocol&gt;
	   This rule applies only to packets of this protocol.	Common protocols are   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/icmp/">icmp(4)</a> ,
	     <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/icmp6/">icmp6(4)</a> ,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/tcp/">tcp(4)</a> , and   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/udp/">udp(4)</a> .  For a list of all the protocol name to number mappings
	   used by   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/pfctl/">pfctl(8)</a> , see the file /etc/protocols.

     from &lt;source&gt; port &lt;source&gt; os &lt;source&gt; to &lt;dest&gt; port &lt;dest&gt;
	   This rule applies only to packets with the specified source and destination addresses
	   and ports.

	   Addresses can be specified in CIDR notation (matching netblocks), as symbolic host
	   names, interface names or interface group names, or as any of the following keywords:

	   any		   Any address.
	   no-route	   Any address which is not currently routable.
	   urpf-failed	   Any source address that fails a unicast reverse path forwarding (URPF)
			   check, i.e. packets coming in on an interface other than that which
			   holds the route back to the packet's source address.
	   &lt;table&gt;	   Any address that matches the given table.

	   Ranges of addresses are specified by using the '-' operator.  For instance:
	   ``10.1.1.10 - 10.1.1.12'' means all addresses from 10.1.1.10 to 10.1.1.12, hence
	   addresses 10.1.1.10, 10.1.1.11, and 10.1.1.12.

	   Interface names and interface group names can have modifiers appended:

	   :network	 Translates to the network(s) attached to the interface.
	   :broadcast	 Translates to the interface's broadcast address(es).
	   :peer	 Translates to the point-to-point interface's peer address(es).
	   :0		 Do not include interface aliases.

	   Host names may also have the :0 option appended to restrict the name resolution to the
	   first of each v4 and v6 address found.

	   Host name resolution and interface to address translation are done at ruleset load-
	   time.  When the address of an interface (or host name) changes (under DHCP or PPP, for
	   instance), the ruleset must be reloaded for the change to be reflected in the kernel.
	   Surrounding the interface name (and optional modifiers) in parentheses changes this
	   behaviour.  When the interface name is surrounded by parentheses, the rule is automat-
	   ically updated whenever the interface changes its address.  The ruleset does not need
	   to be reloaded.  This is especially useful with nat.

	   Ports can be specified either by number or by name.	For example, port 80 can be spec-
	   ified as www.  For a list of all port name to number mappings used by   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/pfctl/">pfctl(8)</a> , see
	   the file /etc/services.

	   Ports and ranges of ports are specified by using these operators:

		 =	 (equal)
		 !=	 (unequal)
		 &lt;	 (less than)
		 &lt;=	 (less than or equal)
		 &gt;	 (greater than)
		 &gt;=	 (greater than or equal)
		 :	 (range including boundaries)
		 &gt;&lt;	 (range excluding boundaries)
		 &lt;&gt;	 (except range)

	   '&gt;&lt;', '&lt;&gt;' and ':' are binary operators (they take two arguments).  For instance:

	   port 2000:2004
		       means 'all ports &gt;= 2000 and &lt;= 2004', hence ports 2000, 2001, 2002, 2003
		       and 2004.

	   port 2000 &gt;&lt; 2004
		       means 'all ports &gt; 2000 and &lt; 2004', hence ports 2001, 2002 and 2003.

	   port 2000 &lt;&gt; 2004
		       means 'all ports &lt; 2000 or &gt; 2004', hence ports 1-1999 and 2005-65535.

	   The operating system of the source host can be specified in the case of TCP rules with
	   the OS modifier.  See the OPERATING SYSTEM FINGERPRINTING section for more informa-
	   tion.

	   The host, port and OS specifications are optional, as in the following examples:

		 pass in all
		 pass in from any to any
		 pass in proto tcp from any port &lt;= 1024 to any
		 pass in proto tcp from any to any port 25
		 pass in proto tcp from 10.0.0.0/8 port &gt; 1024 \
		       to ! 10.1.2.3 port != ssh
		 pass in proto tcp from any os &quot;OpenBSD&quot;

     all   This is equivalent to &quot;from any to any&quot;.

     group &lt;group&gt;
	   Similar to user, this rule only applies to packets of sockets owned by the specified
	   group.

     user &lt;user&gt;
	   This rule only applies to packets of sockets owned by the specified user.  For outgo-
	   ing connections initiated from the firewall, this is the user that opened the connec-
	   tion.  For incoming connections to the firewall itself, this is the user that listens
	   on the destination port.  For forwarded connections, where the firewall is not a con-
	   nection endpoint, the user and group are unknown.

	   All packets, both outgoing and incoming, of one connection are associated with the
	   same user and group.  Only TCP and UDP packets can be associated with users; for other
	   protocols these parameters are ignored.

	   User and group refer to the effective (as opposed to the real) IDs, in case the socket
	   is created by a setuid/setgid process.  User and group IDs are stored when a socket is
	   created; when a process creates a listening socket as root (for instance, by binding
	   to a privileged port) and subsequently changes to another user ID (to drop privi-
	   leges), the credentials will remain root.

	   User and group IDs can be specified as either numbers or names.  The syntax is similar
	   to the one for ports.  The value unknown matches packets of forwarded connections.
	   unknown can only be used with the operators = and !=.  Other constructs like user &gt;=
	   unknown are invalid.  Forwarded packets with unknown user and group ID match only
	   rules that explicitly compare against unknown with the operators = or !=.  For
	   instance user &gt;= 0 does not match forwarded packets.  The following example allows
	   only selected users to open outgoing connections:

		 block out proto { tcp, udp } all
		 pass  out proto { tcp, udp } all user { &lt; 1000, dhartmei }

     flags &lt;a&gt; /&lt;b&gt; | /&lt;b&gt; | any
	   This rule only applies to TCP packets that have the flags &lt;a&gt; set out of set &lt;b&gt;.
	   Flags not specified in &lt;b&gt; are ignored.  For stateful connections, the default is
	   flags S/SA.	To indicate that flags should not be checked at all, specify flags any.
	   The flags are: (F)IN, (S)YN, (R)ST, (P)USH, (A)CK, (U)RG, (E)CE, and C(W)R.

	   flags S/S   Flag SYN is set.  The other flags are ignored.

	   flags S/SA  This is the default setting for stateful connections.  Out of SYN and ACK,
		       exactly SYN may be set.	SYN, SYN+PSH and SYN+RST match, but SYN+ACK, ACK
		       and ACK+RST do not.  This is more restrictive than the previous example.

	   flags /SFRA
		       If the first set is not specified, it defaults to none.	All of SYN, FIN,
		       RST and ACK must be unset.

	   Because flags S/SA is applied by default (unless no state is specified), only the ini-
	   tial SYN packet of a TCP handshake will create a state for a TCP connection.  It is
	   possible to be less restrictive, and allow state creation from intermediate (non-SYN)
	   packets, by specifying flags any.  This will cause   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  to synchronize to existing
	   connections, for instance if one flushes the state table.  However, states created
	   from such intermediate packets may be missing connection details such as the TCP win-
	   dow scaling factor.	States which modify the packet flow, such as those affected by
	   nat, binat or rdr rules, modulate or synproxy state options, or scrubbed with
	   reassemble tcp will also not be recoverable from intermediate packets.  Such connec-
	   tions will stall and time out.

     icmp-type &lt;type&gt; code &lt;code&gt;

     icmp6-type &lt;type&gt; code &lt;code&gt;
	   This rule only applies to ICMP or ICMPv6 packets with the specified type and code.
	   Text names for ICMP types and codes are listed in   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/icmp/">icmp(4)</a>  and   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/icmp6/">icmp6(4)</a> .  This parame-
	   ter is only valid for rules that cover protocols ICMP or ICMP6.  The protocol and the
	   ICMP type indicator (icmp-type or icmp6-type) must match.

     tos &lt;string&gt; | &lt;number&gt;
	   This rule applies to packets with the specified TOS bits set.  TOS may be given as one
	   of lowdelay, throughput, reliability, or as either hex or decimal.

	   For example, the following rules are identical:

		 pass all tos lowdelay
		 pass all tos 0x10
		 pass all tos 16

     allow-opts
	   By default, IPv4 packets with IP options or IPv6 packets with routing extension head-
	   ers are blocked.  When allow-opts is specified for a pass rule, packets that pass the
	   filter based on that rule (last matching) do so even if they contain IP options or
	   routing extension headers.  For packets that match state, the rule that initially cre-
	   ated the state is used.  The implicit pass rule that is used when a packet does not
	   match any rules does not allow IP options.

     label &lt;string&gt;
	   Adds a label (name) to the rule, which can be used to identify the rule.  For
	   instance, pfctl <b><i>-s</i></b> labels shows per-rule statistics for rules that have labels.

	   The following macros can be used in labels:

		 $if	   The interface.
		 $srcaddr  The source IP address.
		 $dstaddr  The destination IP address.
		 $srcport  The source port specification.
		 $dstport  The destination port specification.
		 $proto    The protocol name.
		 $nr	   The rule number.

	   For example:

		 ips = &quot;{ 1.2.3.4, 1.2.3.5 }&quot;
		 pass in proto tcp from any to $ips \
		       port &gt; 1023 label &quot;$dstaddr:$dstport&quot;

	   expands to

		 pass in inet proto tcp from any to 1.2.3.4 \
		       port &gt; 1023 label &quot;1.2.3.4:&gt;1023&quot;
		 pass in inet proto tcp from any to 1.2.3.5 \
		       port &gt; 1023 label &quot;1.2.3.5:&gt;1023&quot;

	   The macro expansion for the label directive occurs only at configuration file parse
	   time, not during runtime.

     queue &lt;queue&gt; | (&lt;queue&gt;, &lt;queue&gt;)
	   Packets matching this rule will be assigned to the specified queue.	If two queues are
	   given, packets which have a TOS of lowdelay and TCP ACKs with no data payload will be
	   assigned to the second one.	See QUEUEING for setup details.

	   For example:

		 pass in proto tcp to port 25 queue mail
		 pass in proto tcp to port 22 queue(ssh_bulk, ssh_prio)

     tag &lt;string&gt;
	   Packets matching this rule will be tagged with the specified string.  The tag acts as
	   an internal marker that can be used to identify these packets later on.  This can be
	   used, for example, to provide trust between interfaces and to determine if packets
	   have been processed by translation rules.  Tags are &quot;sticky&quot;, meaning that the packet
	   will be tagged even if the rule is not the last matching rule.  Further matching rules
	   can replace the tag with a new one but will not remove a previously applied tag.  A
	   packet is only ever assigned one tag at a time.  Packet tagging can be done during
	   nat, rdr, or binat rules in addition to filter rules.  Tags take the same macros as
	   labels (see above).

     tagged &lt;string&gt;
	   Used with filter, translation or scrub rules to specify that packets must already be
	   tagged with the given tag in order to match the rule.  Inverse tag matching can also
	   be done by specifying the ! operator before the tagged keyword.

     rtable &lt;number&gt;
	   Used to select an alternate routing table for the routing lookup.  Only effective
	   before the route lookup happened, i.e. when filtering inbound.

     divert-to &lt;host&gt; port &lt;port&gt;
	   Used to redirect packets to a local socket bound to host and port.  The packets will
	   not be modified, so   <a  style="font-size:1.2em;"  href="/man-page/freebsd/2/getsockname/">getsockname(2)</a>  on the socket will return the original destination
	   address of the packet.

     divert-reply
	   Used to receive replies for sockets that are bound to addresses which are not local to
	   the machine.  See   <a  style="font-size:1.2em;"  href="/man-page/freebsd/2/setsockopt/">setsockopt(2)</a>  for information on how to bind these sockets.

     probability &lt;number&gt;
	   A probability attribute can be attached to a rule, with a value set between 0 and 1,
	   bounds not included.  In that case, the rule will be honoured using the given proba-
	   bility value only.  For example, the following rule will drop 20% of incoming ICMP
	   packets:

		 block in proto icmp probability 20%

<b>ROUTING</b>
     If a packet matches a rule with a route option set, the packet filter will route the packet
     according to the type of route option.  When such a rule creates state, the route option is
     also applied to all packets matching the same connection.

     fastroute
	   The fastroute option does a normal route lookup to find the next hop for the packet.

     route-to
	   The route-to option routes the packet to the specified interface with an optional
	   address for the next hop.  When a route-to rule creates state, only packets that pass
	   in the same direction as the filter rule specifies will be routed in this way.  Pack-
	   ets passing in the opposite direction (replies) are not affected and are routed nor-
	   mally.

     reply-to
	   The reply-to option is similar to route-to, but routes packets that pass in the oppo-
	   site direction (replies) to the specified interface.  Opposite direction is only
	   defined in the context of a state entry, and reply-to is useful only in rules that
	   create state.  It can be used on systems with multiple external connections to route
	   all outgoing packets of a connection through the interface the incoming connection
	   arrived through (symmetric routing enforcement).

     dup-to
	   The dup-to option creates a duplicate of the packet and routes it like route-to.  The
	   original packet gets routed as it normally would.

<b>POOL OPTIONS</b>
     For nat and rdr rules, (as well as for the route-to, reply-to and dup-to rule options) for
     which there is a single redirection address which has a subnet mask smaller than 32 for IPv4
     or 128 for IPv6 (more than one IP address), a variety of different methods for assigning
     this address can be used:

     bitmask
	   The bitmask option applies the network portion of the redirection address to the
	   address to be modified (source with nat, destination with rdr).

     random
	   The random option selects an address at random within the defined block of addresses.

     source-hash
	   The source-hash option uses a hash of the source address to determine the redirection
	   address, ensuring that the redirection address is always the same for a given source.
	   An optional key can be specified after this keyword either in hex or as a string; by
	   default   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/pfctl/">pfctl(8)</a>  randomly generates a key for source-hash every time the ruleset is
	   reloaded.

     round-robin
	   The round-robin option loops through the redirection address(es).

	   When more than one redirection address is specified, round-robin is the only permitted
	   pool type.

     static-port
	   With nat rules, the static-port option prevents   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  from modifying the source port
	   on TCP and UDP packets.

     Additionally, the sticky-address option can be specified to help ensure that multiple con-
     nections from the same source are mapped to the same redirection address.	This option can
     be used with the random and round-robin pool options.  Note that by default these associa-
     tions are destroyed as soon as there are no longer states which refer to them; in order to
     make the mappings last beyond the lifetime of the states, increase the global options with
     set timeout src.track.  See STATEFUL TRACKING OPTIONS for more ways to control the source
     tracking.

<b>STATE MODULATION</b>
     Much of the security derived from TCP is attributable to how well the initial sequence num-
     bers (ISNs) are chosen.  Some popular stack implementations choose very poor ISNs and thus
     are normally susceptible to ISN prediction exploits.  By applying a modulate state rule to a
     TCP connection,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  will create a high quality random sequence number for each connection
     endpoint.

     The modulate state directive implicitly keeps state on the rule and is only applicable to
     TCP connections.

     For instance:

	   block all
	   pass out proto tcp from any to any modulate state
	   pass in  proto tcp from any to any port 25 flags S/SFRA modulate state

     Note that modulated connections will not recover when the state table is lost (firewall
     reboot, flushing the state table, etc...).    <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  will not be able to infer a connection
     again after the state table flushes the connection's modulator.  When the state is lost, the
     connection may be left dangling until the respective endpoints time out the connection.  It
     is possible on a fast local network for the endpoints to start an ACK storm while trying to
     resynchronize after the loss of the modulator.  The default flags settings (or a more strict
     equivalent) should be used on modulate state rules to prevent ACK storms.

     Note that alternative methods are available to prevent loss of the state table and allow for
     firewall failover.  See   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/carp/">carp(4)</a>  and   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pfsync/">pfsync(4)</a>  for further information.

<b>SYN PROXY</b>
     By default,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  passes packets that are part of a   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/tcp/">tcp(4)</a>  handshake between the endpoints.
     The synproxy state option can be used to cause   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  itself to complete the handshake with
     the active endpoint, perform a handshake with the passive endpoint, and then forward packets
     between the endpoints.

     No packets are sent to the passive endpoint before the active endpoint has completed the
     handshake, hence so-called SYN floods with spoofed source addresses will not reach the pas-
     sive endpoint, as the sender can't complete the handshake.

     The proxy is transparent to both endpoints, they each see a single connection from/to the
     other endpoint.    <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  chooses random initial sequence numbers for both handshakes.  Once
     the handshakes are completed, the sequence number modulators (see previous section) are used
     to translate further packets of the connection.  synproxy state includes modulate state.

     Rules with synproxy will not work if   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  operates on a   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/bridge/">bridge(4)</a> .

     Example:

	   pass in proto tcp from any to any port www synproxy state

<b>STATEFUL TRACKING OPTIONS</b>
     A number of options related to stateful tracking can be applied on a per-rule basis.  keep
     state, modulate state and synproxy state support these options, and keep state must be spec-
     ified explicitly to apply options to a rule.

     max &lt;number&gt;
	   Limits the number of concurrent states the rule may create.	When this limit is
	   reached, further packets that would create state will not match this rule until exist-
	   ing states time out.
     no-sync
	   Prevent state changes for states created by this rule from appearing on the   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pfsync/">pfsync(4)</a> 
	   interface.
     &lt;timeout&gt; &lt;seconds&gt;
	   Changes the timeout values used for states created by this rule.  For a list of all
	   valid timeout names, see OPTIONS above.
     sloppy
	   Uses a sloppy TCP connection tracker that does not check sequence numbers at all,
	   which makes insertion and ICMP teardown attacks way easier.	This is intended to be
	   used in situations where one does not see all packets of a connection, e.g. in asym-
	   metric routing situations.  Cannot be used with modulate or synproxy state.
     pflow
	   States created by this rule are exported on the   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pflow/">pflow(4)</a>  interface.

     Multiple options can be specified, separated by commas:

	   pass in proto tcp from any to any \
		 port www keep state \
		 (max 100, source-track rule, max-src-nodes 75, \
		 max-src-states 3, tcp.established 60, tcp.closing 5)

     When the source-track keyword is specified, the number of states per source IP is tracked.

     source-track rule
	   The maximum number of states created by this rule is limited by the rule's
	   max-src-nodes and max-src-states options.  Only state entries created by this particu-
	   lar rule count toward the rule's limits.
     source-track global
	   The number of states created by all rules that use this option is limited.  Each rule
	   can specify different max-src-nodes and max-src-states options, however state entries
	   created by any participating rule count towards each individual rule's limits.

     The following limits can be set:

     max-src-nodes &lt;number&gt;
	   Limits the maximum number of source addresses which can simultaneously have state ta-
	   ble entries.
     max-src-states &lt;number&gt;
	   Limits the maximum number of simultaneous state entries that a single source address
	   can create with this rule.

     For stateful TCP connections, limits on established connections (connections which have com-
     pleted the TCP 3-way handshake) can also be enforced per source IP.

     max-src-conn &lt;number&gt;
	   Limits the maximum number of simultaneous TCP connections which have completed the
	   3-way handshake that a single host can make.
     max-src-conn-rate &lt;number&gt; / &lt;seconds&gt;
	   Limit the rate of new connections over a time interval.  The connection rate is an
	   approximation calculated as a moving average.

     Because the 3-way handshake ensures that the source address is not being spoofed, more
     aggressive action can be taken based on these limits.  With the overload &lt;table&gt; state
     option, source IP addresses which hit either of the limits on established connections will
     be added to the named table.  This table can be used in the ruleset to block further activ-
     ity from the offending host, redirect it to a tarpit process, or restrict its bandwidth.

     The optional flush keyword kills all states created by the matching rule which originate
     from the host which exceeds these limits.	The global modifier to the flush command kills
     all states originating from the offending host, regardless of which rule created the state.

     For example, the following rules will protect the webserver against hosts making more than
     100 connections in 10 seconds.  Any host which connects faster than this rate will have its
     address added to the &lt;bad_hosts&gt; table and have all states originating from it flushed.  Any
     new packets arriving from this host will be dropped unconditionally by the block rule.

	   block quick from &lt;bad_hosts&gt;
	   pass in on $ext_if proto tcp to $webserver port www keep state \
		   (max-src-conn-rate 100/10, overload &lt;bad_hosts&gt; flush global)

<b>OPERATING SYSTEM FINGERPRINTING</b>
     Passive OS Fingerprinting is a mechanism to inspect nuances of a TCP connection's initial
     SYN packet and guess at the host's operating system.  Unfortunately these nuances are easily
     spoofed by an attacker so the fingerprint is not useful in making security decisions.  But
     the fingerprint is typically accurate enough to make policy decisions upon.

     The fingerprints may be specified by operating system class, by version, or by sub-
     type/patchlevel.  The class of an operating system is typically the vendor or genre and
     would be OpenBSD for the   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  firewall itself.  The version of the oldest available OpenBSD
     release on the main FTP site would be 2.6 and the fingerprint would be written

	   &quot;OpenBSD 2.6&quot;

     The subtype of an operating system is typically used to describe the patchlevel if that
     patch led to changes in the TCP stack behavior.  In the case of OpenBSD, the only subtype is
     for a fingerprint that was normalized by the no-df scrub option and would be specified as

	   &quot;OpenBSD 3.3 no-df&quot;

     Fingerprints for most popular operating systems are provided by   <a  style="font-size:1.2em;"  href="/man-page/freebsd/5/pf.os/">pf.os(5)</a> .	Once   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  is
     running, a complete list of known operating system fingerprints may be listed by running:

	   # pfctl <b><i>-so

</i></b>     Filter rules can enforce policy at any level of operating system specification assuming a
     fingerprint is present.  Policy could limit traffic to approved operating systems or even
     ban traffic from hosts that aren't at the latest service pack.

     The unknown class can also be used as the fingerprint which will match packets for which no
     operating system fingerprint is known.

     Examples:

	   pass  out proto tcp from any os OpenBSD
	   block out proto tcp from any os Doors
	   block out proto tcp from any os &quot;Doors PT&quot;
	   block out proto tcp from any os &quot;Doors PT SP3&quot;
	   block out from any os &quot;unknown&quot;
	   pass on lo0 proto tcp from any os &quot;OpenBSD 3.3 lo0&quot;

     Operating system fingerprinting is limited only to the TCP SYN packet.  This means that it
     will not work on other protocols and will not match a currently established connection.

     Caveat: operating system fingerprints are occasionally wrong.  There are three problems: an
     attacker can trivially craft his packets to appear as any operating system he chooses; an
     operating system patch could change the stack behavior and no fingerprints will match it
     until the database is updated; and multiple operating systems may have the same fingerprint.

<b>BLOCKING SPOOFED TRAFFIC</b>
     &quot;Spoofing&quot; is the faking of IP addresses, typically for malicious purposes.  The antispoof
     directive expands to a set of filter rules which will block all traffic with a source IP
     from the network(s) directly connected to the specified interface(s) from entering the sys-
     tem through any other interface.

     For example, the line

	   antispoof for lo0

     expands to

	   block drop in on ! lo0 inet from 127.0.0.1/8 to any
	   block drop in on ! lo0 inet6 from ::1 to any

     For non-loopback interfaces, there are additional rules to block incoming packets with a
     source IP address identical to the interface's IP(s).  For example, assuming the interface
     wi0 had an IP address of 10.0.0.1 and a netmask of 255.255.255.0, the line

	   antispoof for wi0 inet

     expands to

	   block drop in on ! wi0 inet from 10.0.0.0/24 to any
	   block drop in inet from 10.0.0.1 to any

     Caveat: Rules created by the antispoof directive interfere with packets sent over loopback
     interfaces to local addresses.  One should pass these explicitly.

<b>FRAGMENT HANDLING</b>
     The size of IP datagrams (packets) can be significantly larger than the maximum transmission
     unit (MTU) of the network.  In cases when it is necessary or more efficient to send such
     large packets, the large packet will be fragmented into many smaller packets that will each
     fit onto the wire.  Unfortunately for a firewalling device, only the first logical fragment
     will contain the necessary header information for the subprotocol that allows   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  to fil-
     ter on things such as TCP ports or to perform NAT.

     Besides the use of scrub rules as described in TRAFFIC NORMALIZATION above, there are three
     options for handling fragments in the packet filter.

     One alternative is to filter individual fragments with filter rules.  If no scrub rule
     applies to a fragment, it is passed to the filter.  Filter rules with matching IP header
     parameters decide whether the fragment is passed or blocked, in the same way as complete
     packets are filtered.  Without reassembly, fragments can only be filtered based on IP header
     fields (source/destination address, protocol), since subprotocol header fields are not
     available (TCP/UDP port numbers, ICMP code/type).	The fragment option can be used to
     restrict filter rules to apply only to fragments, but not complete packets.  Filter rules
     without the fragment option still apply to fragments, if they only specify IP header fields.
     For instance, the rule

	   pass in proto tcp from any to any port 80

     never applies to a fragment, even if the fragment is part of a TCP packet with destination
     port 80, because without reassembly this information is not available for each fragment.
     This also means that fragments cannot create new or match existing state table entries,
     which makes stateful filtering and address translation (NAT, redirection) for fragments
     impossible.

     It's also possible to reassemble only certain fragments by specifying source or destination
     addresses or protocols as parameters in scrub rules.

     In most cases, the benefits of reassembly outweigh the additional memory cost, and it's rec-
     ommended to use scrub rules to reassemble all fragments via the fragment reassemble modi-
     fier.

     The memory allocated for fragment caching can be limited using   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/pfctl/">pfctl(8)</a> .  Once this limit is
     reached, fragments that would have to be cached are dropped until other entries time out.
     The timeout value can also be adjusted.

     Currently, only IPv4 fragments are supported and IPv6 fragments are blocked unconditionally.

<b>ANCHORS</b>
     Besides the main ruleset,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/pfctl/">pfctl(8)</a>  can load rulesets into anchor attachment points.  An
     anchor is a container that can hold rules, address tables, and other anchors.

     An anchor has a name which specifies the path where   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/pfctl/">pfctl(8)</a>  can be used to access the
     anchor to perform operations on it, such as attaching child anchors to it or loading rules
     into it.  Anchors may be nested, with components separated by '/' characters, similar to how
     file system hierarchies are laid out.  The main ruleset is actually the default anchor, so
     filter and translation rules, for example, may also be contained in any anchor.

     An anchor can reference another anchor attachment point using the following kinds of rules:

     nat-anchor &lt;name&gt;
	   Evaluates the nat rules in the specified anchor.

     rdr-anchor &lt;name&gt;
	   Evaluates the rdr rules in the specified anchor.

     binat-anchor &lt;name&gt;
	   Evaluates the binat rules in the specified anchor.

     anchor &lt;name&gt;
	   Evaluates the filter rules in the specified anchor.

     load anchor &lt;name&gt; from &lt;file&gt;
	   Loads the rules from the specified file into the anchor name.

     When evaluation of the main ruleset reaches an anchor rule,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a>  will proceed to evaluate
     all rules specified in that anchor.

     Matching filter and translation rules marked with the quick option are final and abort the
     evaluation of the rules in other anchors and the main ruleset.  If the anchor itself is
     marked with the quick option, ruleset evaluation will terminate when the anchor is exited if
     the packet is matched by any rule within the anchor.

     anchor rules are evaluated relative to the anchor in which they are contained.  For example,
     all anchor rules specified in the main ruleset will reference anchor attachment points
     underneath the main ruleset, and anchor rules specified in a file loaded from a load anchor
     rule will be attached under that anchor point.

     Rules may be contained in anchor attachment points which do not contain any rules when the
     main ruleset is loaded, and later such anchors can be manipulated through   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/pfctl/">pfctl(8)</a>  without
     reloading the main ruleset or other anchors.  For example,

	   ext_if = &quot;kue0&quot;
	   block on $ext_if all
	   anchor spam
	   pass out on $ext_if all
	   pass in on $ext_if proto tcp from any \
		 to $ext_if port smtp

     blocks all packets on the external interface by default, then evaluates all rules in the
     anchor named &quot;spam&quot;, and finally passes all outgoing connections and incoming connections to
     port 25.

	   # echo &quot;block in quick from 1.2.3.4 to any&quot; | \
		 pfctl <b><i>-a</i></b> spam <b><i>-f</i></b> -

     This loads a single rule into the anchor, which blocks all packets from a specific address.

     The anchor can also be populated by adding a load anchor rule after the anchor rule:

	   anchor spam
	   load anchor spam from &quot;/etc/pf-spam.conf&quot;

     When   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/pfctl/">pfctl(8)</a>  loads pf.conf, it will also load all the rules from the file /etc/pf-spam.conf
     into the anchor.

     Optionally, anchor rules can specify packet filtering parameters using the same syntax as
     filter rules.  When parameters are used, the anchor rule is only evaluated for matching
     packets.  This allows conditional evaluation of anchors, like:

	   block on $ext_if all
	   anchor spam proto tcp from any to any port smtp
	   pass out on $ext_if all
	   pass in on $ext_if proto tcp from any to $ext_if port smtp

     The rules inside anchor spam are only evaluated for tcp packets with destination port 25.
     Hence,

	   # echo &quot;block in quick from 1.2.3.4 to any&quot; | \
		 pfctl <b><i>-a</i></b> spam <b><i>-f</i></b> -

     will only block connections from 1.2.3.4 to port 25.

     Anchors may end with the asterisk ('*') character, which signifies that all anchors attached
     at that point should be evaluated in the alphabetical ordering of their anchor name.  For
     example,

	   anchor &quot;spam/*&quot;

     will evaluate each rule in each anchor attached to the spam anchor.  Note that it will only
     evaluate anchors that are directly attached to the spam anchor, and will not descend to
     evaluate anchors recursively.

     Since anchors are evaluated relative to the anchor in which they are contained, there is a
     mechanism for accessing the parent and ancestor anchors of a given anchor.  Similar to file
     system path name resolution, if the sequence ``..'' appears as an anchor path component, the
     parent anchor of the current anchor in the path evaluation at that point will become the new
     current anchor.  As an example, consider the following:

	   # echo ' anchor &quot;spam/allowed&quot; ' | pfctl <b><i>-f</i></b> -
	   # echo <b><i>-e</i></b> ' anchor &quot;../banned&quot; \n pass' | \
		 pfctl <b><i>-a</i></b> spam/allowed <b><i>-f</i></b> -

     Evaluation of the main ruleset will lead into the spam/allowed anchor, which will evaluate
     the rules in the spam/banned anchor, if any, before finally evaluating the pass rule.

     Filter rule anchors can also be loaded inline in the ruleset within a brace ('{' '}') delim-
     ited block.  Brace delimited blocks may contain rules or other brace-delimited blocks.  When
     anchors are loaded this way the anchor name becomes optional.

	   anchor &quot;external&quot; on egress {
		   block
		   anchor out {
			   pass proto tcp from any to port { 25, 80, 443 }
		   }
		   pass in proto tcp to any port 22
	   }

     Since the parser specification for anchor names is a string, any reference to an anchor name
     containing '/' characters will require double quote ('&quot;') characters around the anchor name.

<b>TRANSLATION EXAMPLES</b>
     This example maps incoming requests on port 80 to port 8080, on which a daemon is running
     (because, for example, it is not run as root, and therefore lacks permission to bind to port
     80).

     # use a macro for the interface name, so it can be changed easily
     ext_if = &quot;ne3&quot;

     # map daemon on 8080 to appear to be on 80
     rdr on $ext_if proto tcp from any to any port 80 -&gt; 127.0.0.1 port 8080

     If the pass modifier is given, packets matching the translation rule are passed without
     inspecting the filter rules:

     rdr pass on $ext_if proto tcp from any to any port 80 -&gt; 127.0.0.1 \
	   port 8080

     In the example below, vlan12 is configured as 192.168.168.1; the machine translates all
     packets coming from 192.168.168.0/24 to 204.92.77.111 when they are going out any interface
     except vlan12.  This has the net effect of making traffic from the 192.168.168.0/24 network
     appear as though it is the Internet routable address 204.92.77.111 to nodes behind any
     interface on the router except for the nodes on vlan12.  (Thus, 192.168.168.1 can talk to
     the 192.168.168.0/24 nodes.)

     nat on ! vlan12 from 192.168.168.0/24 to any -&gt; 204.92.77.111

     In the example below, the machine sits between a fake internal 144.19.74.*  network, and a
     routable external IP of 204.92.77.100.  The no nat rule excludes protocol AH from being
     translated.

     # NO NAT
     no nat on $ext_if proto ah from 144.19.74.0/24 to any
     nat on $ext_if from 144.19.74.0/24 to any -&gt; 204.92.77.100

     In the example below, packets bound for one specific server, as well as those generated by
     the sysadmins are not proxied; all other connections are.

     # NO RDR
     no rdr on $int_if proto { tcp, udp } from any to $server port 80
     no rdr on $int_if proto { tcp, udp } from $sysadmins to any port 80
     rdr on $int_if proto { tcp, udp } from any to any port 80 -&gt; 127.0.0.1 \
	   port 80

     This longer example uses both a NAT and a redirection.  The external interface has the
     address 157.161.48.183.  On localhost, we are running   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/ftp-proxy/">ftp-proxy(8)</a> , waiting for FTP sessions
     to be redirected to it.  The three mandatory anchors for   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/ftp-proxy/">ftp-proxy(8)</a>  are omitted from this
     example; see the   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/ftp-proxy/">ftp-proxy(8)</a>  manpage.

     # NAT
     # Translate outgoing packets' source addresses (any protocol).
     # In this case, any address but the gateway's external address is mapped.
     nat on $ext_if inet from ! ($ext_if) to any -&gt; ($ext_if)

     # NAT PROXYING
     # Map outgoing packets' source port to an assigned proxy port instead of
     # an arbitrary port.
     # In this case, proxy outgoing isakmp with port 500 on the gateway.
     nat on $ext_if inet proto udp from any port = isakmp to any -&gt; ($ext_if) \
	   port 500

     # BINAT
     # Translate outgoing packets' source address (any protocol).
     # Translate incoming packets' destination address to an internal machine
     # (bidirectional).
     binat on $ext_if from 10.1.2.150 to any -&gt; $ext_if

     # RDR
     # Translate incoming packets' destination addresses.
     # As an example, redirect a TCP and UDP port to an internal machine.
     rdr on $ext_if inet proto tcp from any to ($ext_if) port 8080 \
	   -&gt; 10.1.2.151 port 22
     rdr on $ext_if inet proto udp from any to ($ext_if) port 8080 \
	   -&gt; 10.1.2.151 port 53

     # RDR
     # Translate outgoing ftp control connections to send them to localhost
     # for proxying with   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/ftp-proxy/">ftp-proxy(8)</a>  running on port 8021.
     rdr on $int_if proto tcp from any to any port 21 -&gt; 127.0.0.1 port 8021

     In this example, a NAT gateway is set up to translate internal addresses using a pool of
     public addresses (192.0.2.16/28) and to redirect incoming web server connections to a group
     of web servers on the internal network.

     # NAT LOAD BALANCE
     # Translate outgoing packets' source addresses using an address pool.
     # A given source address is always translated to the same pool address by
     # using the source-hash keyword.
     nat on $ext_if inet from any to any -&gt; 192.0.2.16/28 source-hash

     # RDR ROUND ROBIN
     # Translate incoming web server connections to a group of web servers on
     # the internal network.
     rdr on $ext_if proto tcp from any to any port 80 \
	   -&gt; { 10.1.2.155, 10.1.2.160, 10.1.2.161 } round-robin

<b>FILTER EXAMPLES</b>
     # The external interface is kue0
     # (157.161.48.183, the only routable address)
     # and the private network is 10.0.0.0/8, for which we are doing NAT.

     # use a macro for the interface name, so it can be changed easily
     ext_if = &quot;kue0&quot;

     # normalize all incoming traffic
     scrub in on $ext_if all fragment reassemble

     # block and log everything by default
     block return log on $ext_if all

     # block anything coming from source we have no back routes for
     block in from no-route to any

     # block packets whose ingress interface does not match the one in
     # the route back to their source address
     block in from urpf-failed to any

     # block and log outgoing packets that do not have our address as source,
     # they are either spoofed or something is misconfigured (NAT disabled,
     # for instance), we want to be nice and do not send out garbage.
     block out log quick on $ext_if from ! 157.161.48.183 to any

     # silently drop broadcasts (cable modem noise)
     block in quick on $ext_if from any to 255.255.255.255

     # block and log incoming packets from reserved address space and invalid
     # addresses, they are either spoofed or misconfigured, we cannot reply to
     # them anyway (hence, no return-rst).
     block in log quick on $ext_if from { 10.0.0.0/8, 172.16.0.0/12, \
	   192.168.0.0/16, 255.255.255.255/32 } to any

     # ICMP

     # pass out/in certain ICMP queries and keep state (ping)
     # state matching is done on host addresses and ICMP id (not type/code),
     # so replies (like 0/0 for 8/0) will match queries
     # ICMP error messages (which always refer to a TCP/UDP packet) are
     # handled by the TCP/UDP states
     pass on $ext_if inet proto icmp all icmp-type 8 code 0

     # UDP

     # pass out all UDP connections and keep state
     pass out on $ext_if proto udp all

     # pass in certain UDP connections and keep state (DNS)
     pass in on $ext_if proto udp from any to any port domain

     # TCP

     # pass out all TCP connections and modulate state
     pass out on $ext_if proto tcp all modulate state

     # pass in certain TCP connections and keep state (SSH, SMTP, DNS, IDENT)
     pass in on $ext_if proto tcp from any to any port { ssh, smtp, domain, \
	   auth }

     # Do not allow Windows 9x SMTP connections since they are typically
     # a viral worm. Alternately we could limit these OSes to 1 connection each.
     block in on $ext_if proto tcp from any os {&quot;Windows 95&quot;, &quot;Windows 98&quot;} \
	   to any port smtp

     # IPv6
     # pass in/out all IPv6 traffic: note that we have to enable this in two
     # different ways, on both our physical interface and our tunnel
     pass quick on gif0 inet6
     pass quick on $ext_if proto ipv6

     # Packet Tagging

     # three interfaces: $int_if, $ext_if, and $wifi_if (wireless). NAT is
     # being done on $ext_if for all outgoing packets. tag packets in on
     # $int_if and pass those tagged packets out on $ext_if.  all other
     # outgoing packets (i.e., packets from the wireless network) are only
     # permitted to access port 80.

     pass in on $int_if from any to any tag INTNET
     pass in on $wifi_if from any to any

     block out on $ext_if from any to any
     pass out quick on $ext_if tagged INTNET
     pass out on $ext_if proto tcp from any to any port 80

     # tag incoming packets as they are redirected to   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/spamd/">spamd(8)</a> . use the tag
     # to pass those packets through the packet filter.

     rdr on $ext_if inet proto tcp from &lt;spammers&gt; to port smtp \
	     tag SPAMD -&gt; 127.0.0.1 port spamd

     block in on $ext_if
     pass in on $ext_if inet proto tcp tagged SPAMD

<b>GRAMMAR</b>
     Syntax for pf.conf in BNF:

     line	    = ( option | pf-rule | nat-rule | binat-rule | rdr-rule |
		      antispoof-rule | altq-rule | queue-rule | trans-anchors |
		      anchor-rule | anchor-close | load-anchor | table-rule |
		      include )

     option	    = &quot;set&quot; ( [ &quot;timeout&quot; ( timeout | &quot;{&quot; timeout-list &quot;}&quot; ) ] |
		      [ &quot;ruleset-optimization&quot; [ &quot;none&quot; | &quot;basic&quot; | &quot;profile&quot; ]] |
		      [ &quot;optimization&quot; [ &quot;default&quot; | &quot;normal&quot; |
		      &quot;high-latency&quot; | &quot;satellite&quot; |
		      &quot;aggressive&quot; | &quot;conservative&quot; ] ]
		      [ &quot;limit&quot; ( limit-item | &quot;{&quot; limit-list &quot;}&quot; ) ] |
		      [ &quot;loginterface&quot; ( interface-name | &quot;none&quot; ) ] |
		      [ &quot;block-policy&quot; ( &quot;drop&quot; | &quot;return&quot; ) ] |
		      [ &quot;state-policy&quot; ( &quot;if-bound&quot; | &quot;floating&quot; ) ]
		      [ &quot;state-defaults&quot; state-opts ]
		      [ &quot;require-order&quot; ( &quot;yes&quot; | &quot;no&quot; ) ]
		      [ &quot;fingerprints&quot; filename ] |
		      [ &quot;skip on&quot; ifspec ] |
		      [ &quot;debug&quot; ( &quot;none&quot; | &quot;urgent&quot; | &quot;misc&quot; | &quot;loud&quot; ) ] )

     pf-rule	    = action [ ( &quot;in&quot; | &quot;out&quot; ) ]
		      [ &quot;log&quot; [ &quot;(&quot; logopts &quot;)&quot;] ] [ &quot;quick&quot; ]
		      [ &quot;on&quot; ifspec ] [ &quot;fastroute&quot; | route ] [ af ] [ protospec ]
		      hosts [ filteropt-list ]

     logopts	    = logopt [ &quot;,&quot; logopts ]
     logopt	    = &quot;all&quot; | &quot;user&quot; | &quot;to&quot; interface-name

     filteropt-list = filteropt-list filteropt | filteropt
     filteropt	    = user | group | flags | icmp-type | icmp6-type | &quot;tos&quot; tos |
		      ( &quot;no&quot; | &quot;keep&quot; | &quot;modulate&quot; | &quot;synproxy&quot; ) &quot;state&quot;
		      [ &quot;(&quot; state-opts &quot;)&quot; ] |
		      &quot;fragment&quot; | &quot;no-df&quot; | &quot;min-ttl&quot; number | &quot;set-tos&quot; tos |
		      &quot;max-mss&quot; number | &quot;random-id&quot; | &quot;reassemble tcp&quot; |
		      fragmentation | &quot;allow-opts&quot; |
		      &quot;label&quot; string | &quot;tag&quot; string | [ ! ] &quot;tagged&quot; string |
		      &quot;queue&quot; ( string | &quot;(&quot; string [ [ &quot;,&quot; ] string ] &quot;)&quot; ) |
		      &quot;rtable&quot; number | &quot;probability&quot; number&quot;%&quot;

     nat-rule	    = [ &quot;no&quot; ] &quot;nat&quot; [ &quot;pass&quot; [ &quot;log&quot; [ &quot;(&quot; logopts &quot;)&quot; ] ] ]
		      [ &quot;on&quot; ifspec ] [ af ]
		      [ protospec ] hosts [ &quot;tag&quot; string ] [ &quot;tagged&quot; string ]
		      [ &quot;-&gt;&quot; ( redirhost | &quot;{&quot; redirhost-list &quot;}&quot; )
		      [ portspec ] [ pooltype ] [ &quot;static-port&quot; ] ]

     binat-rule     = [ &quot;no&quot; ] &quot;binat&quot; [ &quot;pass&quot; [ &quot;log&quot; [ &quot;(&quot; logopts &quot;)&quot; ] ] ]
		      [ &quot;on&quot; interface-name ] [ af ]
		      [ &quot;proto&quot; ( proto-name | proto-number ) ]
		      &quot;from&quot; address [ &quot;/&quot; mask-bits ] &quot;to&quot; ipspec
		      [ &quot;tag&quot; string ] [ &quot;tagged&quot; string ]
		      [ &quot;-&gt;&quot; address [ &quot;/&quot; mask-bits ] ]

     rdr-rule	    = [ &quot;no&quot; ] &quot;rdr&quot; [ &quot;pass&quot; [ &quot;log&quot; [ &quot;(&quot; logopts &quot;)&quot; ] ] ]
		      [ &quot;on&quot; ifspec ] [ af ]
		      [ protospec ] hosts [ &quot;tag&quot; string ] [ &quot;tagged&quot; string ]
		      [ &quot;-&gt;&quot; ( redirhost | &quot;{&quot; redirhost-list &quot;}&quot; )
		      [ portspec ] [ pooltype ] ]

     antispoof-rule = &quot;antispoof&quot; [ &quot;log&quot; ] [ &quot;quick&quot; ]
		      &quot;for&quot; ifspec [ af ] [ &quot;label&quot; string ]

     table-rule     = &quot;table&quot; &quot;&lt;&quot; string &quot;&gt;&quot; [ tableopts-list ]
     tableopts-list = tableopts-list tableopts | tableopts
     tableopts	    = &quot;persist&quot; | &quot;const&quot; | &quot;counters&quot; | &quot;file&quot; string |
		      &quot;{&quot; [ tableaddr-list ] &quot;}&quot;
     tableaddr-list = tableaddr-list [ &quot;,&quot; ] tableaddr-spec | tableaddr-spec
     tableaddr-spec = [ &quot;!&quot; ] tableaddr [ &quot;/&quot; mask-bits ]
     tableaddr	    = hostname | ifspec | &quot;self&quot; |
		      ipv4-dotted-quad | ipv6-coloned-hex

     altq-rule	    = &quot;altq on&quot; interface-name queueopts-list
		      &quot;queue&quot; subqueue
     queue-rule     = &quot;queue&quot; string [ &quot;on&quot; interface-name ] queueopts-list
		      subqueue

     anchor-rule    = &quot;anchor&quot; [ string ] [ ( &quot;in&quot; | &quot;out&quot; ) ] [ &quot;on&quot; ifspec ]
		      [ af ] [ protospec ] [ hosts ] [ filteropt-list ] [ &quot;{&quot; ]

     anchor-close   = &quot;}&quot;

     trans-anchors  = ( &quot;nat-anchor&quot; | &quot;rdr-anchor&quot; | &quot;binat-anchor&quot; ) string
		      [ &quot;on&quot; ifspec ] [ af ] [ &quot;proto&quot; ] [ protospec ] [ hosts ]

     load-anchor    = &quot;load anchor&quot; string &quot;from&quot; filename

     queueopts-list = queueopts-list queueopts | queueopts
     queueopts	    = [ &quot;bandwidth&quot; bandwidth-spec ] |
		      [ &quot;qlimit&quot; number ] | [ &quot;tbrsize&quot; number ] |
		      [ &quot;priority&quot; number ] | [ schedulers ]
     schedulers     = ( cbq-def | priq-def | hfsc-def )
     bandwidth-spec = &quot;number&quot; ( &quot;b&quot; | &quot;Kb&quot; | &quot;Mb&quot; | &quot;Gb&quot; | &quot;%&quot; )

     action	    = &quot;pass&quot; | &quot;block&quot; [ return ] | [ &quot;no&quot; ] &quot;scrub&quot;
     return	    = &quot;drop&quot; | &quot;return&quot; | &quot;return-rst&quot; [ &quot;( ttl&quot; number &quot;)&quot; ] |
		      &quot;return-icmp&quot; [ &quot;(&quot; icmpcode [ [ &quot;,&quot; ] icmp6code ] &quot;)&quot; ] |
		      &quot;return-icmp6&quot; [ &quot;(&quot; icmp6code &quot;)&quot; ]
     icmpcode	    = ( icmp-code-name | icmp-code-number )
     icmp6code	    = ( icmp6-code-name | icmp6-code-number )

     ifspec	    = ( [ &quot;!&quot; ] ( interface-name | interface-group ) ) |
		      &quot;{&quot; interface-list &quot;}&quot;
     interface-list = [ &quot;!&quot; ] ( interface-name | interface-group )
		      [ [ &quot;,&quot; ] interface-list ]
     route	    = ( &quot;route-to&quot; | &quot;reply-to&quot; | &quot;dup-to&quot; )
		      ( routehost | &quot;{&quot; routehost-list &quot;}&quot; )
		      [ pooltype ]
     af 	    = &quot;inet&quot; | &quot;inet6&quot;

     protospec	    = &quot;proto&quot; ( proto-name | proto-number |
		      &quot;{&quot; proto-list &quot;}&quot; )
     proto-list     = ( proto-name | proto-number ) [ [ &quot;,&quot; ] proto-list ]

     hosts	    = &quot;all&quot; |
		      &quot;from&quot; ( &quot;any&quot; | &quot;no-route&quot; | &quot;urpf-failed&quot; | &quot;self&quot; | host |
		      &quot;{&quot; host-list &quot;}&quot; ) [ port ] [ os ]
		      &quot;to&quot;   ( &quot;any&quot; | &quot;no-route&quot; | &quot;self&quot; | host |
		      &quot;{&quot; host-list &quot;}&quot; ) [ port ]

     ipspec	    = &quot;any&quot; | host | &quot;{&quot; host-list &quot;}&quot;
     host	    = [ &quot;!&quot; ] ( address [ &quot;/&quot; mask-bits ] | &quot;&lt;&quot; string &quot;&gt;&quot; )
     redirhost	    = address [ &quot;/&quot; mask-bits ]
     routehost	    = &quot;(&quot; interface-name [ address [ &quot;/&quot; mask-bits ] ] &quot;)&quot;
     address	    = ( interface-name | interface-group |
		      &quot;(&quot; ( interface-name | interface-group ) &quot;)&quot; |
		      hostname | ipv4-dotted-quad | ipv6-coloned-hex )
     host-list	    = host [ [ &quot;,&quot; ] host-list ]
     redirhost-list = redirhost [ [ &quot;,&quot; ] redirhost-list ]
     routehost-list = routehost [ [ &quot;,&quot; ] routehost-list ]

     port	    = &quot;port&quot; ( unary-op | binary-op | &quot;{&quot; op-list &quot;}&quot; )
     portspec	    = &quot;port&quot; ( number | name ) [ &quot;:&quot; ( &quot;*&quot; | number | name ) ]
     os 	    = &quot;os&quot;  ( os-name | &quot;{&quot; os-list &quot;}&quot; )
     user	    = &quot;user&quot; ( unary-op | binary-op | &quot;{&quot; op-list &quot;}&quot; )
     group	    = &quot;group&quot; ( unary-op | binary-op | &quot;{&quot; op-list &quot;}&quot; )

     unary-op	    = [ &quot;=&quot; | &quot;!=&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;&gt;&quot; | &quot;&gt;=&quot; ]
		      ( name | number )
     binary-op	    = number ( &quot;&lt;&gt;&quot; | &quot;&gt;&lt;&quot; | &quot;:&quot; ) number
     op-list	    = ( unary-op | binary-op ) [ [ &quot;,&quot; ] op-list ]

     os-name	    = operating-system-name
     os-list	    = os-name [ [ &quot;,&quot; ] os-list ]

     flags	    = &quot;flags&quot; ( [ flag-set ] &quot;/&quot;  flag-set | &quot;any&quot; )
     flag-set	    = [ &quot;F&quot; ] [ &quot;S&quot; ] [ &quot;R&quot; ] [ &quot;P&quot; ] [ &quot;A&quot; ] [ &quot;U&quot; ] [ &quot;E&quot; ]
		      [ &quot;W&quot; ]

     icmp-type	    = &quot;icmp-type&quot; ( icmp-type-code | &quot;{&quot; icmp-list &quot;}&quot; )
     icmp6-type     = &quot;icmp6-type&quot; ( icmp-type-code | &quot;{&quot; icmp-list &quot;}&quot; )
     icmp-type-code = ( icmp-type-name | icmp-type-number )
		      [ &quot;code&quot; ( icmp-code-name | icmp-code-number ) ]
     icmp-list	    = icmp-type-code [ [ &quot;,&quot; ] icmp-list ]

     tos	    = ( &quot;lowdelay&quot; | &quot;throughput&quot; | &quot;reliability&quot; |
		      [ &quot;0x&quot; ] number )

     state-opts     = state-opt [ [ &quot;,&quot; ] state-opts ]
     state-opt	    = ( &quot;max&quot; number | &quot;no-sync&quot; | timeout | &quot;sloppy&quot; | &quot;pflow&quot; |
		      &quot;source-track&quot; [ ( &quot;rule&quot; | &quot;global&quot; ) ] |
		      &quot;max-src-nodes&quot; number | &quot;max-src-states&quot; number |
		      &quot;max-src-conn&quot; number |
		      &quot;max-src-conn-rate&quot; number &quot;/&quot; number |
		      &quot;overload&quot; &quot;&lt;&quot; string &quot;&gt;&quot; [ &quot;flush&quot; ] |
		      &quot;if-bound&quot; | &quot;floating&quot; )

     fragmentation  = [ &quot;fragment reassemble&quot; | &quot;fragment crop&quot; |
		      &quot;fragment drop-ovl&quot; ]

     timeout-list   = timeout [ [ &quot;,&quot; ] timeout-list ]
     timeout	    = ( &quot;tcp.first&quot; | &quot;tcp.opening&quot; | &quot;tcp.established&quot; |
		      &quot;tcp.closing&quot; | &quot;tcp.finwait&quot; | &quot;tcp.closed&quot; |
		      &quot;udp.first&quot; | &quot;udp.single&quot; | &quot;udp.multiple&quot; |
		      &quot;icmp.first&quot; | &quot;icmp.error&quot; |
		      &quot;other.first&quot; | &quot;other.single&quot; | &quot;other.multiple&quot; |
		      &quot;frag&quot; | &quot;interval&quot; | &quot;src.track&quot; |
		      &quot;adaptive.start&quot; | &quot;adaptive.end&quot; ) number

     limit-list     = limit-item [ [ &quot;,&quot; ] limit-list ]
     limit-item     = ( &quot;states&quot; | &quot;frags&quot; | &quot;src-nodes&quot; ) number

     pooltype	    = ( &quot;bitmask&quot; | &quot;random&quot; |
		      &quot;source-hash&quot; [ ( hex-key | string-key ) ] |
		      &quot;round-robin&quot; ) [ sticky-address ]

     subqueue	    = string | &quot;{&quot; queue-list &quot;}&quot;
     queue-list     = string [ [ &quot;,&quot; ] string ]
     cbq-def	    = &quot;cbq&quot; [ &quot;(&quot; cbq-opt [ [ &quot;,&quot; ] cbq-opt ] &quot;)&quot; ]
     priq-def	    = &quot;priq&quot; [ &quot;(&quot; priq-opt [ [ &quot;,&quot; ] priq-opt ] &quot;)&quot; ]
     hfsc-def	    = &quot;hfsc&quot; [ &quot;(&quot; hfsc-opt [ [ &quot;,&quot; ] hfsc-opt ] &quot;)&quot; ]
     cbq-opt	    = ( &quot;default&quot; | &quot;borrow&quot; | &quot;red&quot; | &quot;ecn&quot; | &quot;rio&quot; )
     priq-opt	    = ( &quot;default&quot; | &quot;red&quot; | &quot;ecn&quot; | &quot;rio&quot; )
     hfsc-opt	    = ( &quot;default&quot; | &quot;red&quot; | &quot;ecn&quot; | &quot;rio&quot; |
		      linkshare-sc | realtime-sc | upperlimit-sc )
     linkshare-sc   = &quot;linkshare&quot; sc-spec
     realtime-sc    = &quot;realtime&quot; sc-spec
     upperlimit-sc  = &quot;upperlimit&quot; sc-spec
     sc-spec	    = ( bandwidth-spec |
		      &quot;(&quot; bandwidth-spec number bandwidth-spec &quot;)&quot; )
     include	    = &quot;include&quot; filename

<b>FILES</b>
     /etc/hosts      Host name database.
     /etc/pf.conf    Default location of the ruleset file.
     /etc/pf.os      Default location of OS fingerprints.
     /etc/protocols  Protocol name database.
     /etc/services   Service name database.

<b>SEE ALSO</b>
       <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/altq/">altq(4)</a> ,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/carp/">carp(4)</a> ,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/icmp/">icmp(4)</a> ,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/icmp6/">icmp6(4)</a> ,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/ip/">ip(4)</a> ,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/ip6/">ip6(4)</a> ,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pf/">pf(4)</a> ,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pflow/">pflow(4)</a> ,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/pfsync/">pfsync(4)</a> ,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/tcp/">tcp(4)</a> ,
       <a  style="font-size:1.2em;"  href="/man-page/freebsd/4/udp/">udp(4)</a> ,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/5/hosts/">hosts(5)</a> ,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/5/pf.os/">pf.os(5)</a> ,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/5/protocols/">protocols(5)</a> ,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/5/services/">services(5)</a> ,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/ftp-proxy/">ftp-proxy(8)</a> ,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/pfctl/">pfctl(8)</a> ,   <a  style="font-size:1.2em;"  href="/man-page/freebsd/8/pflogd/">pflogd(8)</a> 

<b>HISTORY</b>
     The pf.conf file format first appeared in OpenBSD 3.0.

<b>BSD</b>					  June 29, 2012 				      BSD</pre></td>
<td width="10%">           </td>
</tr>
</table>




</td>
</tr>


 

	<tr align="center">
		<td class="thead">
			<div class="smallfont">
			</div>
		</td>
	</tr>
</table>
<!-- /Body Code -->

<br />


<br />
<div class="smallfont" align="center">All times are GMT -4. The time now is <span class="time">05:45 PM</span>.</div>
<br />




		</div>
	</div>
</div>

<!-- / close content container -->
<!-- /content area table -->

<form action="index.php" method="get">
	
<table cellpadding="6" cellspacing="0" border="0" width="100%" class="page" align="center">
<tr>



	
	
	<td class="tfoot" align="right" width="100%">

		<div class="smallfont"
			<strong>


				
				
				

                                
				
				<a href="#top" onclick="self.scrollTo(0, 0); return false;">Top</a>
			</strong>
		</div>
	</td>
</tr>
</table>
</form>






<script type="text/javascript">
<!--
	// Main vBulletin Javascript Initialization
	vBulletin_init(); 
-->
</script>

<div class="footer" style="padding:8px;font-size:9px ">
<!--
<div align="right">UNIX is a registered trademark of The Open Group</div>
-->
	<div style="float:right"> 
     <div>
     </div>
UNIX and Linux Forums
	</div>
	<div align="left">Search Engine Optimisation provided by 
        
        
        
</div>












<script language="JavaScript">
<!--
if (document.f) {
document.f.query.focus();
document.f.query.select();
}
// -->
</script>

</body>
</html>
