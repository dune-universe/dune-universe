(******************************************************************************
 * OC4.5
 * A pure OCaml implementation of C4.5 algorithm
 *
 * By Théophile Bastian <contact@tobast.fr>
 * and Noémie Fong (aka. Minithorynque), 2016.
 ******************************************************************************
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *****************************************************************************)

(** This module is used to generate decision trees from data sets, using
C4.5.

To use this module, you first have to instantiate it for a given data type,
which will be used for continuous data, with {!Oc45.Make}[(...)]. You can
also use one of the two predefined modules {!IntOc45} and {!FloatOc45},
using respectively native integers and float as a continuous data type.
*)

module type Comparable = sig
	type t
	(** The type of the elements *)
	val compare : t -> t -> int
	(** A function such that [compare a b] is zero if [a] equals [b] and
	is strictly negative (resp. positive) if [a] is smaller (resp. greater)
	than [b]. In most cases, Pervasives.compare will do. *)
	val avg : t -> t -> t
	(** A function that returns "the average" of its two arguments, or the
	closest thing to it.

	This is used to split the tree between two values. The only important thing
	is that, if [a < b], [a <= avg a b < b].
	*)
end

module type S = sig
	(** {6 Data types } *)

	exception InvalidArgument of string
	(** Raised when trying to construct a data set with wrong arguments.*)

	(** A feature id. *)
	type feature = int

	exception BadContinuity of feature
	(** Raised when appending a data vector with a continuous feature instead
	of a discrete one, or the other way. *)

    exception DiscreteFeatOutOfBounds of feature * int
    (** [DiscreteFeatureOutOfBounds feat class] is raised when trying to
    classify a data vector with its discrete feature [feat] equal to [class]
    when the tree was created assuming that the values for this feature would
    remain [< class].
    This usually means that the value is very rare and was not encountered in
    the training set, thus the limit inferred for the maximal value of this
    feature is not high enough. You then have to set it manually, using
    {!setFeatureMax}. *)

	(** A category (ie. classification) id. *)
	type category = int

	(** The type of a continuous data, defined through {!Oc45.Make} *)
	type contData

	(** A value of a feature field. *)
	type dataVal = Discrete of int | Continuous of contData

	(** A feature/data value association table. *)
	type data = dataVal array

	(** A value used to train the algorithm. *)
	type trainVal = {
		data : data ;
		(** Associates each feature id to its value. If the feature is
		continuous, it may take any value; if the feature is discrete,
		it must be an integer in a range 0..N inclusive for a bound N
		inferred as the maximum of the given data. You can also set
		this bound manually with {!val:setFeatureMax}. *)

		category : category
		(** The category to which this data vector belongs. *)
	}

	(** Generated by {!val:emptyTrainSet}, represents a training set
	for the algorithm. *)
	type trainSet

	(** Output of {!val:c45}. *)
	type decisionTree

	(** {6 Main functions} *)

	(** Generates a decision tree from a training set.
	@param trainSet The training set used, see {!val:emptyTrainSet}. *)
	val c45 : trainSet -> decisionTree

	(** Classifies a data vector, given a decision tree. *)
	val classify : decisionTree -> data -> category

	(** {6 Training set manipulation} *)

	(** [emptyTrainSet nbFeatures nbCategories featContinuity] creates an
	empty train set with [nbFeatures] features and [nbCategories]
	categories. The array [featContinuity] must have [nbFeatures]
	elements, with a [true] value if
	the corresponding feature is continuous (that is, may take any value) or
	[false] if the feature is discrete in a restrained set (eg., "Yes"/"No").

	Raises {!exception:InvalidArgument} if [featContinuity] has not a length
	of [nbFeatures]
	*)
	val emptyTrainSet : int -> int -> bool array -> trainSet

	(** Adds the given value to the training set. *)
	val addData : trainVal -> trainSet -> trainSet

	(** Adds a list of data vectors to the given training set. *)
	val addDataList : trainVal list -> trainSet -> trainSet

	(** Extracts the data vector list from a training set. *)
	val getSet : trainSet -> trainVal list

	(** [setFeatureMax feat maxVal trainSet] sets the maximum value the
	{e discrete} feature [feat] may take. A discrete value is represented by
	an integer between 0 and [maxVal] (inclusive).

	In most cases, you won't have to call this function and the bound will be
	automatically set to the maximum value you gave, but you can still set
	it in case you need to have more values that are not represented.
	*)
	val setFeatureMax : int -> int -> trainSet -> unit

	(** Returns the number of features. *)
	val getNbFeatures : trainSet -> int

	(** Returns the feature bound array, see {!val:setFeatureMax}. *)
	val getFeatureMax : trainSet -> int array

	(** Returns the feature continuity array, see {!val:emptyTrainSet}. *)
	val getFeatContinuity : trainSet -> bool array

	(** Returns the number of categories. *)
	val getNbCategories : trainSet -> int

	(** Returns the number of training cases in a given training set. *)
	val getSetSize : trainSet -> int

	(** {6 Pretty-printing} *)

	(** Pretty-prints the given decision tree as a Dot file in the given
	formatter, using the second argument as a pretty-printer for the
	{!contData} type (ie., the type of a continuous data). *)
	val toDot : Format.formatter -> (Format.formatter -> contData -> unit)
		-> decisionTree -> unit

	(** Same as {!val:toDot}, but prints directly to [stdout]. *)
	val toDotStdout : (Format.formatter -> contData -> unit) -> decisionTree
		-> unit

end
(** Output signature of the functor {!Oc45.Make}. *)

module Make (X : Comparable) : S with type contData = X.t
(** Constructs a module {!Oc45.S} with the given comparable type as
a continuous data value.

Eg., to obtain a module {!Oc45.S} working on floats, you can define
[module FloatOc45 = Oc45.Make(sig type t=float let compare = compare end)].
*)

module IntOc45 : S with type contData = int
(** Similar to {!Oc45.Make}[(struct type t = int let ... end)] *)

module FloatOc45 : S with type contData = float
(** Similar to {!Oc45.Make}[(struct type t = float let ... end)] *)
